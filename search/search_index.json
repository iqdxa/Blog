{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u4ecb\u7ecd","text":"<p>\u8fd9\u662f\u4e00\u4e2a\u505a\u7b14\u8bb0\u7684\u5730\u65b9\uff0c\u968f\u4fbf\u5199\u5199\u3002\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u9047\u5230\u7684\u95ee\u9898\u53ca\u89e3\u51b3\u529e\u6cd5\uff0c\u65b9\u4fbf\u4ee5\u540e\u67e5\u9605\u3002</p> <p>\u70b9\u51fb\u5de6\u4fa7\u76ee\u5f55\u6d4f\u89c8\u76f8\u5173\u5185\u5bb9\u3002</p> <p>\u672c\u7f51\u7ad9\u521b\u5efa\u4e8e2025-07-05</p>"},{"location":"%E5%A8%B1%E4%B9%90/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/PCL%E6%AD%A3%E7%89%88%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/","title":"PCL\u6b63\u7248\u9a8c\u8bc1\u95ee\u9898","text":"<ul> <li>\u53c2\u8003\uff1a\u4e3a\u4ec0\u4e48\u79bb\u7ebf\u8fd8\u9700\u8981\u6b63\u7248\u9a8c\u8bc1\u554a\uff01\uff01\uff01\u3010pcl2\u5427\u3011_\u767e\u5ea6\u8d34\u5427</li> </ul>"},{"location":"%E5%A8%B1%E4%B9%90/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/PCL%E6%AD%A3%E7%89%88%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_1","title":"\u95ee\u9898","text":"<p>\u5982\u679c\u7535\u8111\u4f7f\u7528\u82f1\u6587\u8bed\u8a00\uff0c\u5728\u4f7f\u7528PCL\u542f\u52a8\u6211\u7684\u4e16\u754c\u4f1a\u51fa\u73b0<code>\u6b63\u7248\u9a8c\u8bc1</code>\uff1a <pre><code>\u4f60\u5fc5\u987b\u5148\u767b\u5f55\u6b63\u7248\u8d26\u53f7\uff0c\u624d\u80fd\u8fdb\u884c\u79bb\u7ebf\u767b\u5f55\uff01\n</code></pre></p>"},{"location":"%E5%A8%B1%E4%B9%90/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/PCL%E6%AD%A3%E7%89%88%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/#_2","title":"\u89e3\u51b3","text":"<p>\u5c06\u7535\u8111\u8bed\u8a00\u8bbe\u7f6e\u6210\u4e2d\u6587\u3002</p>"},{"location":"%E5%A8%B1%E4%B9%90/%E7%BC%BA%E6%B0%A7/%E7%BC%BA%E6%B0%A7%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/","title":"\u7f3a\u6c27\u7ecf\u9a8c\u603b\u7ed3","text":"<p>\u6807\u7b7e\uff1a #\u7f3a\u6c27 #\u603b\u7ed3</p> <p><code>admonish info   \u57fa\u4e8e\u65e0\u654c\u7248\uff08\u590d\u5236\u4eba\u4e0d\u4f1a\u4ea7\u751f\u538b\u529b\uff0c\u4e0d\u6d88\u8017\u98df\u7269\uff0c\u4e0d\u4f1a\u751f\u75c5\uff09\u603b\u7ed3\u7684\u7ecf\u9a8c\u3002 \u867d\u7136\u65e0\u654c\u7248\u5c11\u4e86\u4e00\u4e9b\u4e50\u8da3\uff0c\u4f46\u662f\u53ef\u4ee5\u5feb\u901f\u4f53\u9a8c\u6574\u4e2a\u53d1\u5c55\u8fc7\u7a0b\u3002</code></p> <ul> <li>\u4f7f\u7528\u900f\u6c14\u7816\u65b9\u4fbf\u6c14\u4f53\u6d41\u52a8</li> <li>\u5728\u627e\u5230\u6c34\u6e90\u540e\u4f7f\u7528\u7535\u89e3\u6c34\u5236\u9020\u6c27\u6c14\u4ee5\u51cf\u5c11\u85fb\u7c7b\u4f7f\u7528</li> <li>\u5728\u6709\u94c1\u9508\u65f6\u4f7f\u7528\u94c1\u9508\u5236\u6c27</li> <li>\u4e00\u4e2a\u623f\u95f44\u683c\u9ad8\u5ea6</li> <li>\u706b\u5c71\u55b7\u53e3\u9644\u8fd1\u4f7f\u7528\u9694\u70ed\u7816</li> <li>\u8fdc\u79bb\u706b\u5c71</li> <li>\u628a\u4e0d\u9700\u8981\u7684\u6c14\u4f53\u55b7\u53e3\u5c01\u6389</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/Android/%E4%BD%BF%E7%94%A8ADB%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/","title":"\u4f7f\u7528ADB\u5378\u8f7d\u624b\u673a\u7cfb\u7edf\u5e94\u7528","text":""},{"location":"%E5%AD%A6%E4%B9%A0/Android/%E4%BD%BF%E7%94%A8ADB%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/#adb","title":"ADB\u5b89\u88c5","text":""},{"location":"%E5%AD%A6%E4%B9%A0/Android/%E4%BD%BF%E7%94%A8ADB%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/#android-studio","title":"\u5df2\u5b89\u88c5Android Studio\u7684\u60c5\u51b5","text":"<ul> <li>\u627e\u5230Android Studio SDK\u6587\u4ef6\u6240\u5728\u4f4d\u7f6e\uff0cSDK---&gt;platform-tools---&gt;\u627e\u5230adb\u7684\u7edd\u5bf9\u8def\u5f84\u3002</li> <li>\u6dfb\u52a0\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/Android/%E4%BD%BF%E7%94%A8ADB%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/#android-studio_1","title":"\u672a\u5b89\u88c5Android Studio\u7684\u60c5\u51b5","text":"<ul> <li>\u76f4\u63a5\u5728\u5b98\u7f51\u4e0b\u8f7dADB\u7ec4\u4ef6\uff0c\u5b98\u7f51\uff1aSDK Platform Tools release notes \u00a0|\u00a0 Android Studio \u00a0|\u00a0 Android Developers</li> <li>\u6dfb\u52a0\u73af\u5883\u53d8\u91cf</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/Android/%E4%BD%BF%E7%94%A8ADB%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/#adb_1","title":"ADB\u4f7f\u7528","text":"<ul> <li>\u67e5\u770bADB\u7248\u672c <pre><code>adb --version\n</code></pre></li> <li>\u8fdb\u5165\u4ea4\u4e92\u6a21\u5f0f <pre><code>adb shell\n</code></pre></li> <li>\u67e5\u770b\u8fde\u63a5\u7684\u8bbe\u5907 <pre><code>adb devices\n</code></pre></li> <li>\u5378\u8f7d\u547d\u4ee4 <pre><code>pm uninstall -k --user 0 \u8f6f\u4ef6\u5305\u540d\n</code></pre></li> <li>\u663e\u793a\u6240\u6709\u5e94\u7528\u5305\u540d <pre><code>pm list packages\n</code></pre></li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/Android/%E4%BD%BF%E7%94%A8ADB%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8/#_1","title":"\u5e38\u89c1\u8f6f\u4ef6\u5378\u8f7d\u547d\u4ee4","text":"<ul> <li>\u534e\u4e3a\u97f3\u4e50 <pre><code>pm uninstall -k --user 0 com.android.mediacenter\n</code></pre> \u6216\u8005 <pre><code>pm uninstall -k --user 0 com.huawei.music\n</code></pre></li> <li>\u534e\u4e3a\u667a\u6167 <pre><code>pm uninstall -k --user 0 com.huawei.intelligent\n</code></pre></li> <li>\u534e\u4e3a\u94b1\u5305 <pre><code>pm uninstall -k --user 0 com.huawei.wallet\n</code></pre></li> <li>\u767e\u5ea6\u8f93\u5165\u6cd5\uff08\u534e\u4e3a\u7248\uff09 <pre><code>pm uninstall -k --user 0 com.baidu.input_huawei\n</code></pre></li> <li>\u534e\u4e3a\u89c6\u9891 <pre><code>pm uninstall -k --user 0 com.huawei.himovie\n</code></pre></li> <li>\u5feb\u5e94\u7528 <pre><code>pm uninstall -k --user 0 com.huawei.fastapp\n</code></pre></li> <li>\u667a\u6167\u641c\u7d22 <pre><code>pm uninstall -k --user 0 com.huawei.search\n</code></pre></li> <li>\u5c0f\u827a\u5efa\u8bae <pre><code>pm uninstall -k --user 0 com.huawei.ohos.suggestion\n</code></pre></li> <li>\u9501\u5c4f\u6742\u5fd7 <pre><code>pm uninstall -k --user 0 com.huawei.magazine\n</code></pre></li> <li>\u4e3b\u9898 <pre><code>pm uninstall --user 0 com.huawei.android.thememanager\n</code></pre></li> <li>\u6211\u7684\u534e\u4e3a <pre><code>pm uninstall --user 0 com.huawei.phoneservice\n</code></pre></li> <li>\u534e\u4e3a\u6d4f\u89c8\u5668 <pre><code>pm uninstall --user 0 com.huawei.browser\n</code></pre></li> <li>\u8054\u7cfb\u4eba <pre><code>pm uninstall --user 0 com.huawei.contacts\n</code></pre></li> <li>\u534e\u4e3a\u5e94\u7528\u5e02\u573a <pre><code>pm uninstall --user 0 com.huawei.appmarket\n</code></pre></li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E6%A0%87%E5%87%86%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","title":"FPGA\u6807\u51c6\u5de5\u7a0b\u6587\u4ef6\u683c\u5f0f","text":"<p>\u4e3a\u4e86\u65b9\u4fbf\u7ba1\u7406\uff0c\u4e00\u4e2aFPGA\u5de5\u7a0b\u5e94\u8be5\u5305\u542b\u5982\u4e0b\u6587\u4ef6\u5939\uff1a</p> <ul> <li>doc: \u5b58\u653e\u5de5\u7a0b\u6587\u6863</li> <li>prj: \u5b58\u653eFPGA\u9879\u76ee</li> <li>rtl: \u5b58\u653e\u4ee3\u7801</li> <li>testbench: \u5b58\u653e\u6d4b\u8bd5\u7528\u4f8b</li> <li>xdc: \u5b58\u653e\u7ea6\u675f\u6587\u4ef6</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E6%96%B9%E6%B3%95/","title":"FPGA\u7a0b\u5e8f\u56fa\u5316\u65b9\u6cd5","text":"<ul> <li>\u53c2\u8003\uff1a\u6b63\u70b9\u539f\u5b50B\u7ad9\u5b98\u65b9\u6559\u5b66\u89c6\u9891</li> </ul> <p>\u4e3a\u4e86\u56fa\u5316\u7a0b\u5e8f\uff0c\u9700\u8981\u8bbe\u7f6e\u4e0a\u7535\u540e\u5feb\u901f\u542f\u52a8\uff0c\u4ee5\u53ca\u4ea7\u751fbin\u6587\u4ef6\u5e76\u5199\u5165bin\u6587\u4ef6\u5230Flash\u3002</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E6%96%B9%E6%B3%95/#_1","title":"\u8bbe\u7f6e\u4e0a\u7535\u540e\u5feb\u901f\u542f\u52a8","text":"<p>\u4e3a\u4e86\u5b9e\u73b0FPGA\u4e0a\u7535\u540e\u5feb\u901f\u542f\u52a8\uff0c\u5728\u7ba1\u811a\u7ea6\u675f\u6587\u4ef6\u4e2d\u6dfb\u52a0\u5982\u4e0b\u5185\u5bb9\uff1a <pre><code>#SPI \u76f8\u5173\u8bbe\u7f6e \u7528\u4e8e\u4e0a\u7535\u540e\u5feb\u901f\u542f\u52a8\nset_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]\nset_property CONFIG_MODE SPIx4 [current_design]\nset_property BITSTREAM.CONFIG.CONFIGRATE 50 [current_design]\nset_property CFGBVS VCCO [current_design]\nset_property CONFIG_VOLTAGE 3.3 [current_design]\n# \u8bbe\u7f6e\u672a\u4f7f\u7528\u7684\u5f15\u811a\u4e0a\u62c9\uff0c\u6839\u636e\u5b9e\u9645\u9700\u8981\u8fdb\u884c\u914d\u7f6e\nset_property BITSTREAM.CONFIG.UNUSEDPIN PULLUP [current_design] \n</code></pre></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E6%96%B9%E6%B3%95/#vivadobin","title":"\u8bbe\u7f6eVivado\u751f\u5b58bin\u6587\u4ef6\u7684\u65b9\u6cd5","text":"<ul> <li>\u70b9\u51fb\u8bbe\u7f6e</li> <li>\u70b9\u51fbProject Setting\u4e0b\u7684Bitstream</li> <li>\u52fe\u9009<code>-bit_file</code>\u540e\u7684\u5355\u9009\u6846</li> <li>\u70b9\u51fbok</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E6%96%B9%E6%B3%95/#bin","title":"\u751f\u6210bin\u6587\u4ef6","text":"<ul> <li>\u70b9\u51fb<code>Generate Bitstream</code>\u751f\u6210bit\u6d41</li> <li>\u5728FPGA\u9879\u76ee\u4e0b\u7684<code>runs\\impl_1</code>\u6587\u4ef6\u5939\u4e2d\u5b58\u5728<code>.bin</code>\u683c\u5f0f\u7684\u6587\u4ef6\uff0c\u5373\u56fa\u5316\u6587\u4ef6</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E6%96%B9%E6%B3%95/#mcs","title":"\u751f\u6210MCS\u6587\u4ef6\uff08\u53ef\u8df3\u8fc7\uff09","text":"<ul> <li>\u9009\u62e9\u83dc\u5355\u680f\u7684<code>Tools</code></li> <li>\u9009\u62e9\u4e0b\u62c9\u83dc\u5355\u7684<code>Generate Memory Configuration File</code>\u9009\u9879</li> <li>\u6839\u636e\u5b9e\u9645Flash\u5927\u5c0f\u914d\u7f6e<code>Custom Memory Size</code>\uff0c\u6ce8\u610f\u6b64\u5904\u5355\u4f4d\u662f==MB==</li> <li>\u8bbe\u7f6e\u8981\u751f\u6210\u7684MCS\u6587\u4ef6\u8def\u5f84\u548c\u540d\u79f0</li> <li>\u7531\u4e8e\u7ea6\u675f\u8bed\u53e5\u91cc\u9762\u662f<code>SPIx4</code>\uff0c\u6240\u4ee5<code>Interface</code>\u9009\u62e9<code>SPIx4</code></li> <li>\u9009\u4e2d<code>Load bitstream files</code>\u9009\u9879\uff0c\u5728<code>Bitfile</code>\u4e2d\u9009\u62e9bit\u6587\u4ef6</li> <li>\u9009\u4e2d\uff1a<code>Write checksum</code>\u3001<code>Disable bit swapping</code>\u3001<code>Overwrite</code></li> <li>\u590d\u5236<code>Command</code>\u547d\u4ee4\uff0c\u7528\u4e8e\u4ee5\u540e\u5feb\u901f\u751f\u6210MCS\u6587\u4ef6</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/FPGA%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%E6%96%B9%E6%B3%95/#_2","title":"\u56fa\u5316\u7a0b\u5e8f","text":"<ul> <li>\u70b9\u51fb<code>Open Hardware Manager</code></li> <li>\u9009\u62e9\u83dc\u5355\u680f\u7684<code>Tools</code></li> <li>\u9009\u62e9\u4e0b\u62c9\u83dc\u5355\u7684<code>Add Configuration Memory Device</code>\u9009\u9879</li> <li>\u6839\u636eFlash\u578b\u53f7\u8fdb\u884c\u914d\u7f6e</li> <li>\u9009\u62e9\u56fa\u5316\u6587\u4ef6\uff08bin\u6216\u8005MCS\u6587\u4ef6\uff09</li> <li>\u70b9\u51fbok</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/%E5%88%9D%E5%AD%A6%E8%80%85FPGA%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9/","title":"\u521d\u5b66\u8005FPGA\u5f00\u53d1\u677f\u9009\u62e9","text":"<ul> <li>\u53c2\u8003\uff1a<ul> <li>\u5982\u4f55\u9009\u62e9\u9002\u5408\u521d\u5b66\u8005\u7684FPGA\u5f00\u53d1\u677f\uff1f | \u5d4c\u5165\u5f0f\u5f00\u53d1</li> <li>FPGA\u5f00\u53d1\u677f\u7684\u9009\u62e9\uff0cAltera\u8fd8\u662fXilinx\u516c\u53f8\u7684\u677f\u5b50\u5462\uff1f \u65b0\u624b\u6c42\u63a8\u8350\u677f\u5b50\u578b\u53f7\uff0c\u6700\u597d\u6709\u8d2d\u4e70\u94fe\u63a5\uff1f</li> <li>Xilinx\u4e4bFPGA\u5668\u4ef6\u7cfb\u5217\u7b80\u4ecb - \u77e5\u4e4e</li> <li>10\u5206\u949f\u4e86\u89e3Xilinx 7\u7cfb\u5217FPGA - \u77e5\u4e4e</li> <li>XILINX FPGA\u7b80\u4ecb-\u578b\u53f7\u7cfb\u5217\u5206\u7c7b\u53c2\u8003 - \u77e5\u4e4e</li> </ul> </li> </ul> <p>\u6700\u8fd1\u60f3\u8981\u5165\u95e8FPGA\uff0c\u9700\u8981\u9009\u62e9\u5408\u9002\u7684\u5f00\u53d1\u677f\u3002\u5c31\u5728\u7f51\u4e0a\u67e5\u627e\u4e86\u4e00\u4e9b\u8d44\u6599\uff0c\u65b9\u4fbf\u81ea\u5df1\u8fdb\u884c\u9009\u62e9\u3002\u56e0\u4e3a\u6211\u504f\u5411\u4e8eXilinx\uff0c\u6240\u4ee5\u5c31\u66f4\u504f\u5411\u4e8eXilinx\u7684\u5185\u5bb9\u3002</p> <p>\u5982\u4f55\u9009\u62e9\u5f00\u53d1\u677f\uff0c\u5173\u952e\u8fd8\u662f\u8981\u6839\u636e\u81ea\u5df1\u7684\u5b9e\u9645\u9700\u6c42\u800c\u8fdb\u884c\u9009\u62e9\u3002</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/%E5%88%9D%E5%AD%A6%E8%80%85FPGA%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9/#fpga_1","title":"FPGA\u82af\u7247\u5236\u9020\u5546","text":"<ul> <li>Xilinx\u3001Altera\u662f\u4e3b\u8981\u7684FPGA\u5236\u9020\u5546\uff0cXilinx\u91cd\u5728\u9ad8\u7aef\u4ea7\u54c1\u7ebf\uff0c\u800cAltera\u91cd\u5728\u4e2d\u4f4e\u7aef\u4ea7\u54c1\u7ebf\u3002</li> <li>\u521d\u5b66\u9636\u6bb5\u53ef\u4ee5\u9009\u7528Altera\u7684\u5f00\u53d1\u677f\uff0c\u4ef7\u683c\u4fbf\u5b9c\uff0c\u5b66\u4e60\u8d44\u6599\u4e30\u5bcc\uff0c\u6709\u4e86\u4e00\u5b9a\u7684\u7ecf\u9a8c\u4ee5\u540e\uff0c\u53ef\u4ee5\u7528Xilinx\u7684\u5f00\u53d1\u677f\u3002</li> <li>Altera\u5bf9\u5e94\u5f00\u53d1\u8f6f\u4ef6\u4e3aQuartus\uff0cXilinx\u5bf9\u5e94\u5f00\u53d1\u8f6f\u4ef6\u4e3aVivado(\u4e4b\u524d\u4e3aISE\uff0c\u66f4\u65b0\u523014.7\u540e\u4e0d\u518d\u66f4\u65b0\uff09\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/%E5%88%9D%E5%AD%A6%E8%80%85FPGA%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9/#xilinx","title":"Xilinx\u82af\u7247\u547d\u540d\u89c4\u5219","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/%E5%88%9D%E5%AD%A6%E8%80%85FPGA%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9/#_1","title":"\u6309\u7167\u4ee3\u6570\u5206","text":"<p>\u6309\u7167\u4ea7\u54c1\u4ee3\u6570\uff0c\u5206\u4e3a6\u4ee3\uff0c7\u4ee3\uff0cUltrascale\uff0cUltrascale+\uff0cVersal\u3002 6\u4ee3\u662f\u8f83\u65e9\u7684\u5668\u4ef6\uff0c\u73b0\u5728\u57fa\u672c\u662f7\u4ee3\u53ca\u4e4b\u540e\u7684\u4ea7\u54c1\uff0c\u6700\u65b0\u7684\u4e00\u4ee3\u662fVersal\uff0c\u4e3b\u8981\u7528\u4e8e\u4eba\u5de5\u667a\u80fd\u9886\u57df\u3002</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/%E5%88%9D%E5%AD%A6%E8%80%85FPGA%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9/#_2","title":"\u6309\u7167\u7cfb\u5217\u5206","text":"<ul> <li> <p>6\u4ee3FPGA\u82af\u7247\u4e3b\u8981\u5206\u4e3aSpartan\u3001Virtex\u3002</p> </li> <li> <p>7\u4ee3FPGA\u82af\u7247\u4e3b\u8981\u5206\u4e3aSpartan\u3001Artix\u3001Kintex\u548cVirtex\u56db\u4e2a\u7cfb\u5217\u3002</p> <ul> <li>Spartan-7\u7cfb\u5217\u662f\u5165\u95e8\u7ea7\u4ea7\u54c1\uff0c\u6709\u7740\u6700\u4f4e\u7684\u4ef7\u683c\u3001\u529f\u8017\u548c\u5c3a\u5bf8\uff0c\u9002\u7528\u4e8e\u4f4e\u7aef\u5e94\u7528\u3002</li> <li>Artix-7\u7cfb\u5217\u589e\u52a0\u4e86\u4e32\u884c\u6536\u53d1\u5668\u548cDSP\u529f\u80fd\uff0c\u5177\u6709\u66f4\u5927\u7684\u903b\u8f91\u5bb9\u91cf\uff0c\u9002\u5408\u903b\u8f91\u7a0d\u5fae\u590d\u6742\u7684\u4e2d\u4f4e\u7aef\u5e94\u7528\u3002</li> <li>Kintex-7\u7cfb\u5217\u5728\u786c\u6838\u6570\u91cf\u548c\u903b\u8f91\u5bb9\u91cf\u65b9\u9762\u90fd\u8868\u73b0\u4f18\u5f02\uff0c\u9002\u7528\u4e8e\u4e2d\u4f4e\u7aef\u548c\u90e8\u5206\u9ad8\u7aef\u5e94\u7528\u3002</li> <li>Virtex-7\u7cfb\u5217\u5728\u9ad8\u7aef\u5e94\u7528\u4e2d\u4f7f\u7528\uff0c\u5bf9\u4e8e\u4e2d\u4f4e\u7aef\u5e94\u7528\u6765\u8bf4\u8fc7\u4e8e\u5f3a\u5927\u800c\u663e\u5f97\u5927\u6750\u5c0f\u7528\u3002</li> </ul> </li> <li> <p>Ultrascale\uff1a KINTEX\u3001VIRTEX</p> </li> <li> <p>Ultrascale+\uff1a ARTIX\u3001KINTEX\u3001VIRTEX\u3001ZYNQ\u3002\uff08ZYNQ\u8868\u793a\u96c6\u6210\u4e86arm\u82af\u7247\uff09</p> </li> <li> <p>Versal\uff1a AI Core\u3001AI Edge\u3001Prime\u3001Premium\uff0c\u4e3b\u8981\u7528\u4e8eAI\u9886\u57df\uff0c\u4f7f\u7528\u4e86ACAP\u81ea\u9002\u5e94\u52a0\u901f\u5e73\u53f0\uff0c\u91c7\u7528\u5f02\u6784\u52a0\u901f\uff0c\u5728\u8f6f\u4ef6\u548c\u786c\u4ef6\u7ea7\u522b\u4e0a\u8fdb\u884c\u52a8\u6001\u81ea\u5b9a\u4e49\u6765\u9002\u5e94\u5404\u79cd\u5e94\u7528\u573a\u666f\u3002</p> </li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/%E5%88%9D%E5%AD%A6%E8%80%85FPGA%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%89%E6%8B%A9/#_3","title":"\u5f00\u53d1\u677f\u9009\u62e9","text":"<ul> <li>\u4f7f\u7528Altera\u82af\u7247\u7684\u5f00\u53d1\u677f\u8981\u6bd4Xilinx\u7684\u4fbf\u5b9c\u3002</li> <li>\u5982\u679c\u91c7\u7528Xilinx\u7684\u82af\u7247\uff0c7\u4ee3\u4ee5\u540e\u7684\u82af\u7247\uff0c\u53ef\u4ee5\u4f7f\u7528Vivado\u5f00\u53d1\uff0c6\u4ee3\u53ca\u4ee5\u524d\u7684\u82af\u7247\uff0c\u9700\u8981\u4f7f\u7528ISE\u8f6f\u4ef6\u5f00\u53d1\uff0c\u4f46\u662fISE\u8f6f\u4ef6\u5df2\u7ecf\u4e0d\u518d\u66f4\u65b0\uff0c\u5728win11\u4e0a\u5b58\u5728\u517c\u5bb9\u95ee\u9898\u3002\u6240\u4ee5\u867d\u71366\u4ee3\u82af\u7247\u4fbf\u5b9c\uff0c\u4f46\u662f\u4e0d\u63a8\u8350\u3002</li> <li>ZYNQ\u8868\u793a\u96c6\u6210\u4e86Arm\u82af\u7247\uff0c\u4f46\u662f\u521d\u5b66\u8005\u53ef\u80fd\u4e0d\u4f1a\u7528\u5230\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e70\u4e0d\u5e26\u6709ZYNQ\u7684\u82af\u7247\uff0c\u51cf\u5c11\u8d2d\u4e70\u6210\u672c\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/7420/","title":"7420","text":"<ul> <li>\u6765\u6e90\uff1a7420 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/7420/#problem-statement","title":"Problem Statement","text":"<p>The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.</p> <p>Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.</p> <p></p> Tip <p>You need to drive two signals (<code>p1y</code>\u00a0and\u00a0<code>p2y</code>) with a value.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/7420/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( \n    input p1a, p1b, p1c, p1d,\n    output p1y,\n    input p2a, p2b, p2c, p2d,\n    output p2y );\n\n    assign p1y = ~(p1a &amp; p1b &amp; p1c &amp; p1d);\n    assign p2y = ~(p2a &amp; p2b &amp; p2c &amp; p2d);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Another_gate/","title":"Exams/m2014 q4f","text":"<ul> <li>\u6765\u6e90\uff1aExams/m2014 q4f - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Another_gate/#problem-statement","title":"Problem Statement","text":"<p>Implement the following circuit:</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Another_gate/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input in1,\n    input in2,\n    output out);\n\n    assign out = in1 &amp; (~in2);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/GND/","title":"Exams/m2014 q4i","text":"<ul> <li>\u6765\u6e90\uff1aExams/m2014 q4i - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/GND/#problem-statement","title":"Problem Statement","text":"<p>Implement the following circuit:</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/GND/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    output out);\n\n    assign out = 1'b0;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gates/","title":"Gates","text":"<ul> <li>\u6765\u6e90\uff1aGates - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gates/#problem-statement","title":"Problem Statement","text":"<p>Ok, let's try building several logic gates at the same time. Build a combinational circuit with two inputs,\u00a0a\u00a0and\u00a0b.</p> <p>There are 7 outputs, each with a logic gate driving it:</p> <ul> <li>out_and: a and b</li> <li>out_or: a or b</li> <li>out_xor: a xor b</li> <li>out_nand: a nand b</li> <li>out_nor: a nor b</li> <li>out_xnor: a xnor b</li> <li>out_anotb: a and-not b</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gates/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input a, b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a &amp; b;\n    assign out_or  = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a &amp; b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~ (a ^ b);\n    assign out_anotb = a &amp; (~b);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gates/#note","title":"Note","text":"<ul> <li>a and-not b\u5c31\u662fa\u91cc\u9762\u4e0d\u5305\u542bb\u7684\u90e8\u5206\uff0c\u5c31\u662f~b\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv/","title":"Gatesv","text":"<ul> <li>\u6765\u6e90\uff1aGatesv - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv/#problem-statement","title":"Problem Statement","text":"<p>You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour:</p> <ul> <li>out_both: Each bit of this output vector should indicate whether\u00a0both\u00a0the corresponding input bit and its neighbour to the\u00a0left\u00a0(higher index) are '1'. For example,\u00a0out_both[2]\u00a0should indicate if\u00a0in[2]\u00a0and\u00a0in[3]\u00a0are both 1. Since\u00a0in[3]\u00a0has no neighbour to the left, the answer is obvious so we don't need to know\u00a0out_both[3].</li> <li>out_any: Each bit of this output vector should indicate whether\u00a0any\u00a0of the corresponding input bit and its neighbour to the\u00a0right\u00a0are '1'. For example,\u00a0out_any[2]\u00a0should indicate if either\u00a0in[2]\u00a0or\u00a0in[1]\u00a0are 1. Since\u00a0in[0]\u00a0has no neighbour to the right, the answer is obvious so we don't need to know\u00a0out_any[0].</li> <li>out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the\u00a0left. For example,\u00a0out_different[2]\u00a0should indicate if\u00a0in[2]\u00a0is different from\u00a0in[3]. For this part, treat the vector as wrapping around, so\u00a0in[3]'s neighbour to the left is\u00a0in[0].</li> </ul> Tip <p>The\u00a0both,\u00a0any, and\u00a0different\u00a0outputs use two-input AND, OR, and XOR operations, respectively. Using vectors, this can be done in 3 assign statements.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // Use bitwise operators and part-select to do the entire calculation in one line of code\n    // in[3:1] is this vector:                       in[3]  in[2]  in[1]\n    // in[2:0] is this vector:                       in[2]  in[1]  in[0]\n    // Bitwise-OR produces a 3 bit vector.             |      |      |\n    // Assign this 3-bit result to out_any[3:1]:    o_a[3] o_a[2] o_a[1]\n\n    // Thus, each output bit is the OR of the input bit and its neighbour to the right:\n    // e.g., out_any[1] = in[1] | in[0];    \n    // Notice how this works even for long vectors.\n    assign out_any = in[3:1] | in[2:0];\n\n    assign out_both = in[2:0] &amp; in[3:1];\n\n    // XOR 'in' with a vector that is 'in' rotated to the right by 1 position: {in[0], in[3:1]}\n    // The rotation is accomplished by using part selects[] and the concatenation operator{}.\n    assign out_different = in ^ {in[0], in[3:1]};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different );\n\n    assign out_both = {in[3] &amp; in[2], in[2] &amp; in[1], in[1] &amp; in[0]};\n    assign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\n    assign out_different = {in[0] ^ in[3], in[3] ^ in[2], in[2] ^ in[1], in[1] ^ in[0]};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv100/","title":"Gatesv100","text":"<ul> <li>\u6765\u6e90\uff1aGatesv100 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv100/#problem-statement","title":"Problem Statement","text":"<p>See also the shorter version:\u00a0Gates and vectors.</p> <p>You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour:</p> <ul> <li>out_both: Each bit of this output vector should indicate whether\u00a0both\u00a0the corresponding input bit and its neighbour to the\u00a0left\u00a0are '1'. For example,\u00a0out_both[98]\u00a0should indicate if\u00a0in[98]\u00a0and\u00a0in[99]\u00a0are both 1. Since\u00a0in[99]\u00a0has no neighbour to the left, the answer is obvious so we don't need to know\u00a0out_both[99].</li> <li>out_any: Each bit of this output vector should indicate whether\u00a0any\u00a0of the corresponding input bit and its neighbour to the\u00a0right\u00a0are '1'. For example,\u00a0out_any[2]\u00a0should indicate if either\u00a0in[2]\u00a0or\u00a0in[1]\u00a0are 1. Since\u00a0in[0]\u00a0has no neighbour to the right, the answer is obvious so we don't need to know\u00a0out_any[0].</li> <li>out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the\u00a0left. For example,\u00a0out_different[98]\u00a0should indicate if\u00a0in[98]\u00a0is different from\u00a0in[99]. For this part, treat the vector as wrapping around, so\u00a0in[99]'s neighbour to the left is\u00a0in[0].</li> </ul> Tip <p>Using vectors, this can\u00a0still\u00a0be done in 3 assign statements.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv100/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // See gatesv for explanations.\n    assign out_both = in &amp; in[99:1];\n    assign out_any = in[99:1] | in ;\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Gatesv100/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different );\n\n    assign out_any = in[99:1] | in[98:0];\n    assign out_both = in[98:0] &amp; in[99:1];\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_eq2/","title":"Mt2015 eq2","text":"<ul> <li>\u6765\u6e90\uff1aMt2015 eq2 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_eq2/#problem-statement","title":"Problem Statement","text":"<p>Taken from 2015 midterm question 1k</p> <p>Create a circuit that has two 2-bit inputs\u00a0A[1:0]\u00a0and\u00a0B[1:0], and produces an output\u00a0z. The value of\u00a0z\u00a0should be 1 if\u00a0A = B, otherwise\u00a0z\u00a0should be 0.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_eq2/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A[1:0]==B[1:0]);    // Comparisons produce a 1 or 0 result.\n\n    // Another option is to use a 16-entry truth table ( {A,B} is 4 bits, with 16 combinations ).\n    // There are 4 rows with a 1 result.  0000, 0101, 1010, and 1111.\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_eq2/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( input [1:0] A, input [1:0] B, output z ); \n\n    always @(*) begin\n        if(A == B)\n            z = 1'b1;\n        else\n            z = 1'b0;\n    end\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_eq2/#note","title":"Note","text":"<ul> <li>\u62a5\u9519\uff1a <pre><code>Error (10170): Verilog HDL syntax error at top_module.v(3) near text: \"if\";  expecting \"endmodule\". Check for and fix any syntax errors that appear immediately before or at the specified keyword. \n</code></pre></li> <li>\u641c\u7d22\u4e86\u53d1\u73b0\u662f\u56e0\u4e3aif\u8bed\u53e5\u9700\u8981\u5728always\u5757\u91cc\u9762\u624d\u80fd\u8fd0\u884c\u3002</li> <li>\u5b98\u65b9\u7b54\u6848\u7ed9\u7684\u65b9\u6cd5\u5c31\u4e0d\u9700\u8981\u4f7f\u7528if\u8bed\u53e5\uff0c\u4ee3\u7801\u5c31\u5f88\u7b80\u6d01\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4/","title":"Mt2015 q4","text":"<ul> <li>\u6765\u6e90\uff1aMt2015 q4 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4/#problem-statement","title":"Problem Statement","text":"<p>Taken from 2015 midterm question 4</p> <p>See\u00a0mt2015_q4a\u00a0and\u00a0mt2015_q4b\u00a0for the submodules used here. The top-level design consists of two instantiations each of subcircuits A and B, as shown below.</p> <p></p> <p>Implement this circuit.</p> Tip <p>You may choose to create this circuit hierarchically using the two submodules as shown in the diagram, or create the same functionality without hierarchy.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input x,\n    input y,\n    output z);\n\n    wire o1, o2, o3, o4;\n\n    A ia1 (x, y, o1);\n    B ib1 (x, y, o2);\n    A ia2 (x, y, o3);\n    B ib2 (x, y, o4);\n\n    assign z = (o1 | o2) ^ (o3 &amp; o4);\n\n    // Or you could simplify the circuit including the sub-modules:\n    // assign z = x|~y;\n\nendmodule\n\nmodule A (\n    input x,\n    input y,\n    output z);\n\n    assign z = (x^y) &amp; x;\n\nendmodule\n\nmodule B (\n    input x,\n    input y,\n    output z);\n\n    assign z = ~(x^y);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4/#my-solution","title":"My Solution","text":"<pre><code>module top_module (input x, input y, output z);\n\n    reg z_IA1,z_IB1,z_IA2,z_IB2;\n    reg z_or,z_and;\n\n    A IA1(\n        .x(x),\n        .y(y),\n        .z(z_IA1)\n    );\n\n    A IA2(\n        .x(x),\n        .y(y),\n        .z(z_IA2)\n    );\n\n    B IB1(\n        .x(x),\n        .y(y),\n        .z(z_IB1)\n    );\n\n    B IB2(\n        .x(x),\n        .y(y),\n        .z(z_IB2)\n    );\n\n    assign z_or = z_IA1 | z_IB1;\n    assign z_and= z_IA2 &amp; z_IB2;\n    assign z = z_or ^ z_and;\n\nendmodule\n\nmodule A (input x, input y, output z);\n\n    assign z = (x ^ y) &amp; x;\n\nendmodule\n\nmodule B ( input x, input y, output z );\n\n    assign z = x &amp; y | ~x &amp; ~y;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4a/","title":"Mt2015 q4a","text":"<ul> <li>\u6765\u6e90\uff1aMt2015 q4a - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4a/#problem-statement","title":"Problem Statement","text":"<p>Taken from 2015 midterm question 4</p> <p>Module A is supposed to implement the function\u00a0z = (x^y) &amp; x. Implement this module.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4a/#my-solution","title":"My Solution","text":"<pre><code>module top_module (input x, input y, output z);\n\n    assign z = (x ^ y) &amp; x;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4b/","title":"Mt2015 q4b","text":"<ul> <li>\u6765\u6e90\uff1aMt2015 q4b - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4b/#problem-statement","title":"Problem Statement","text":"<p>Taken from 2015 midterm question 4</p> <p>Circuit B can be described by the following simulation waveform:\u00a0</p> <p>Implement this circuit.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4b/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input x,\n    input y,\n    output z);\n\n    // The simulation waveforms gives you a truth table:\n    // y x   z\n    // 0 0   1\n    // 0 1   0\n    // 1 0   0\n    // 1 1   1   \n    // Two minterms: \n    // assign z = (~x &amp; ~y) | (x &amp; y);\n\n    // Or: Notice this is an XNOR.\n    assign z = ~(x^y);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4b/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( input x, input y, output z );\n\n    assign z = x &amp; y | ~x &amp; ~y;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Mt2015_q4b/#note","title":"Note","text":"<ul> <li>\u6839\u636e\u6ce2\u5f62\u56fe\u5217\u771f\u503c\u8868</li> </ul> x y z 0 0 1 1 0 0 0 1 0 1 1 1 - \u6839\u636e\u771f\u503c\u8868\u5217\u5361\u8bfa\u56fe x/y 0 1 0 1 0 1 0 1 - \u6839\u636e\u5361\u8bfa\u56fe\u53ef\u5f97\uff1a$z = xy + \\overline{x}\\overline{y}=x\\bigodot y$"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/NOR/","title":"Exams/m2014 q4e","text":"<ul> <li>\u6765\u6e90\uff1aExams/m2014 q4e - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/NOR/#problem-statement","title":"Problem Statement","text":"<p>Implement the following circuit:</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/NOR/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input in1,\n    input in2,\n    output out);\n\n    assign out = ~(in1|in2);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/NOR/#note","title":"Note","text":"<ul> <li>\u6ce8\u610f\u8fd0\u7b97\u987a\u5e8f\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Popcount3/","title":"Popcount3","text":"<ul> <li>\u6765\u6e90\uff1aPopcount3 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Popcount3/#problem-statement","title":"Problem Statement","text":"<p>A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Popcount3/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // This is a function of 3 inputs. One method is to use a 8-entry truth table:\n    // in[2:0] out[1:0]\n    // 000      00\n    // 001      01\n    // 010      01\n    // 011      10\n    // 100      01\n    // 101      10\n    // 110      10\n    // 111      11\n    assign out[0] = (~in[2] &amp; ~in[1] &amp; in[0]) | (~in[2] &amp; in[1] &amp; ~in[0]) | (in[2] &amp; ~in[1] &amp; ~in[0]) | (in[2] &amp; in[1] &amp; in[0]);\n    assign out[1] = (in[1] &amp; in[0]) | (in[2] &amp; in[0]) | (in[2] &amp; in[1]);\n\n    // Using the addition operator works too:\n    // assign out = in[0]+in[1]+in[2];\n\n    // Yet another method uses behavioural code inside a procedure (combinational always block)\n    // to directly implement the truth table:\n    /*\n    always @(*) begin\n        case (in)\n            3'd0: out = 2'd0;\n            3'd1: out = 2'd1;\n            3'd2: out = 2'd1;\n            3'd3: out = 2'd2;\n            3'd4: out = 2'd1;\n            3'd5: out = 2'd2;\n            3'd6: out = 2'd2;\n            3'd7: out = 2'd3;\n        endcase\n    end\n    */\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Popcount3/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [2:0] in,\n    output [1:0] out );\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Ringer/","title":"Ringer","text":"<ul> <li>\u6765\u6e90\uff1aRinger - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Ringer/#problem-statement","title":"Problem Statement","text":"<p>Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (<code>input\u00a0**ring**</code>), your circuit must either turn on the ringer (<code>output\u00a0**ringer**\u00a0= 1</code>) or the motor (<code>output\u00a0**motor**\u00a0= 1</code>), but not both. If the phone is in vibrate mode (<code>input\u00a0**vibrate_mode**\u00a0= 1</code>), turn on the motor. Otherwise, turn on the ringer.</p> <p>Try to use only\u00a0<code>assign</code>\u00a0statements, to see whether you can translate a problem description into a collection of logic gates.</p> <p>Design hint:\u00a0When designing circuits, one often has to think of the problem \"backwards\", starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think \"If (inputs are ___ ) then (output should be ___ )\". On the other hand, hardware designers often think \"The (output should be ___ ) when (inputs are ___ )\".</p> <p>The above problem description is written in an imperative form suitable for software programming (if ring then do this), so you must convert it to a more declarative form suitable for hardware implementation (<code>_assign ringer = ____</code>). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design.</p> <p></p> Tip <p>For this particular problem, one should be thinking\u00a0\"The motor is on when ___\", rather than\u00a0\"If (vibrate mode) then ___\".</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Ringer/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // When should ringer be on? When (phone is ringing) and (phone is not in vibrate mode)\n    assign ringer = ring &amp; ~vibrate_mode;\n\n    // When should motor be on? When (phone is ringing) and (phone is in vibrate mode)\n    assign motor = ring &amp; vibrate_mode;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Ringer/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input ring,\n    input vibrate_mode,\n    output ringer,       // Make sound\n    output motor         // Vibrate\n);\n    always@(*)begin\n        if(ring)begin\n            if(vibrate_mode)begin\n                motor &lt;= 1'b1;\n                ringer &lt;= 1'b0;\n            end\n            else begin\n                motor &lt;= 1'b0;\n                ringer &lt;= 1'b1;\n            end\n        end\n        else begin\n            motor &lt;= 1'b0;\n            ringer &lt;= 1'b0;\n        end\n    end\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Thermostat/","title":"Thermostat","text":"<ul> <li>\u6765\u6e90\uff1aThermostat - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Thermostat/#problem-statement","title":"Problem Statement","text":"<p>A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.</p> <p>The thermostat can be in one of two modes: heating (<code>mode = 1</code>) and cooling (<code>mode = 0</code>). In heating mode, turn the heater on when it is too cold (<code>too_cold = 1</code>) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (<code>too_hot = 1</code>), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (<code>fan_on = 1</code>), even if the heater and air conditioner are off.</p> <p>Try to use only\u00a0<code>assign</code>\u00a0statements, to see whether you can translate a problem description into a collection of logic gates.</p> Tip <p>When designing circuits, one often has to think of the problem \"backwards\", starting from the outputs then working backwards towards the inputs. See\u00a0ringer.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Thermostat/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input too_cold, \n    input too_hot,\n    input mode,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n    // Reminder: The order in which you write assign statements doesn't matter. \n    // assign statements describe circuits, so you get the same circuit in the end\n    // regardless of which portion you describe first.\n\n    // Fan should be on when either heater or aircon is on, and also when requested to do so (fan_on = 1).\n    assign fan = heater | aircon | fan_on;\n\n    // Heater is on when it's too cold and mode is \"heating\".\n    assign heater = (mode &amp; too_cold);\n\n    // Aircon is on when it's too hot and mode is not \"heating\".\n    assign aircon = (~mode &amp; too_hot);\n\n    // * Unlike real thermostats, there is no \"off\" mode here.\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Thermostat/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input too_cold,\n    input too_hot,\n    input mode,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n); \n\n    assign heater = too_cold &amp; mode;\n    assign aircon = too_hot &amp; ~mode;\n    assign fan = fan_on | heater | aircon;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Thermostat/#note","title":"Note","text":"<ul> <li>\u5728heater\u548caircon\u5f00\u542f\u65f6\uff0c\u9700\u8981\u5f00\u542ffan\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/","title":"Truthtable1","text":"<ul> <li>\u6765\u6e90\uff1aTruthtable1 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/#problem-statement","title":"Problem Statement","text":"<p>In the previous exercises, we used simple logic gates and combinations of several logic gates. These circuits are examples of\u00a0combinational\u00a0circuits. Combinational means the outputs of the circuit is a function (in the mathematics sense) of only its inputs. This means that for any given input value, there is only one possible output value. Thus, one way to describe the behaviour of a combinational function is to explicitly list what the output should be for every possible value of the inputs. This is a truth table.</p> <p>For a boolean function of N inputs, there are 2N\u00a0possible input combinations. Each row of the truth table lists one input combination, so there are always 2N\u00a0rows. The output column shows what the output should be for each input value.</p> Row number Inputs Outputs f x3 x2 x1 0 0 0 0 0 1 0 0 1 0 2 0 1 0 1 3 0 1 1 1 4 1 0 0 0 5 1 0 1 1 6 1 1 0 0 7 1 1 1 1 <p>The above truth table is for a three-input, one-output function. It has 8 rows for each of the 8 possible input combinations, and one output column. There are four inputs combinations where the output is 1, and four where the output is 0.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/#synthesizing-a-circuit-from-a-truth-table","title":"Synthesizing a circuit from a truth table","text":"<p>Suppose we want to build the above circuit, but we're limited to using only the set of standard logic gates. How would you build arbitrary logic functions (expressed as a truth table)?</p> <p>One simple method to create a circuit that implements the truth table's function is to express the function in sum-of-products form.\u00a0Sum\u00a0(meaning OR) of\u00a0products\u00a0(meaning AND) means using one\u00a0N-input AND gate per row of the truth table (to detect when the input matches each row), followed by an OR gate that chooses only those rows that result in a '1' output.</p> <p>For the above example, the output is '1' if the input matches row 2\u00a0or\u00a0row 3\u00a0or\u00a0row 5\u00a0or\u00a0row 7 (This is a 4-input OR gate). The input matches row 2 if x3=0\u00a0and\u00a0x2=1\u00a0and\u00a0x1=0 (This is a 3-input AND gate). Thus, this truth table can be implemented in\u00a0canonical\u00a0form by using 4 AND gates that are ORed together.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/#a-bit-of-practice","title":"A Bit of Practice","text":"<p>Create a combinational circuit that implements the above truth table.</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    // This truth table has four minterms. \n    assign f = ( ~x3 &amp; x2 &amp; ~x1 ) | \n                ( ~x3 &amp; x2 &amp; x1 ) |\n                ( x3 &amp; ~x2 &amp; x1 ) |\n                ( x3 &amp; x2 &amp; x1 ) ;\n\n    // It can be simplified, by boolean algebra or Karnaugh maps.\n    // assign f = (~x3 &amp; x2) | (x3 &amp; x1);\n\n    // You may then notice that this is actually a 2-to-1 mux, selected by x3:\n    // assign f = x3 ? x1 : x2;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input x3,\n    input x2,\n    input x1,  // three inputs\n    output f   // one output\n);\n\n    assign f = x1 &amp; x3 | x2 &amp; (~x3);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Truthtable1/#note","title":"Note","text":"<ul> <li>\u6839\u636e\u771f\u503c\u8868\u753b\u51fa\u5361\u8bfa\u56fe</li> </ul> x3/x2x1 00 01 11 10 0 0 0 1 1 1 0 1 1 0 - \u6839\u636e\u5361\u8bfa\u56fe\u53ef\u4ee5\u5199\u51fa\u8868\u8fbe\u5f0f\uff1a$f=x_1x_3 + x_2\\overline{x_3}$ - \u5b98\u65b9\u7b54\u6848\u7ed9\u51fa\u4e86\u4f7f\u7528\u6761\u4ef6\u64cd\u4f5c\u7b26\u7684\u4ee3\u7801\uff0c\u5c31\u4f7f\u5f97\u4ee3\u7801\u66f4\u52a0\u7684\u7b80\u6d01\u3002"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Two_gates/","title":"Exams/m2014 q4g","text":"<ul> <li>\u6765\u6e90\uff1aExams/m2014 q4g - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Two_gates/#problem-statement","title":"Problem Statement","text":"<p>Implement the following circuit:</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Two_gates/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output out);\n\n    assign out = in3 ^ (~(in1 ^ in2));\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Two_gates/#note","title":"Note","text":"<ul> <li>\u56fe\u4e2d\u5de6\u8fb9\u662f\u540c\u6216\u95e8\uff0c\u53f3\u8fb9\u662f\u5f02\u6216\u95e8</li> <li>\u5f02\u6216\u95e8\u4f7f\u7528<code>^</code>\u8fd0\u7b97\u7b26</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Wire/","title":"Exams/m2014 q4h","text":"<ul> <li>\u6765\u6e90\uff1aExams/m2014 q4h - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Wire/#problem-statement","title":"Problem Statement","text":"<p>Implement the following circuit:</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/BasicGates/Wire/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input in,\n    output out);\n\n    assign out = in;\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1/","title":"Mux2to1","text":"<ul> <li>\u6765\u6e90\uff1aMux2to1 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1/#problem-statement","title":"Problem Statement","text":"<p>Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</p> Tip <p>The ternary operator\u00a0(cond\u00a0? iftrue\u00a0: iffalse)\u00a0is easier to read.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = (sel &amp; b) | (~sel &amp; a);    // Mux expressed as AND and OR\n\n    // Ternary operator is easier to read, especially if vectors are used:\n    // assign out = sel ? b : a;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input a, b, sel,\n    output out ); \n\n    assign out = sel ? b : a;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1v/","title":"Mux2to1v","text":"<ul> <li>\u6765\u6e90\uff1aMux2to1v - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1v/#problem-statement","title":"Problem Statement","text":"<p>Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</p> Tip <p>The ternary operator\u00a0(cond\u00a0? iftrue\u00a0: iffalse)\u00a0is easier to read.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1v/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\n    // The following doesn't work. Why?\n    // assign out = (sel &amp; b) | (~sel &amp; a);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux2to1v/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [99:0] a, b,\n    input sel,\n    output [99:0] out );\n\n    assign out = sel ? b : a;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux9to1v/","title":"Mux9to1v","text":"<ul> <li>\u6765\u6e90\uff1aMux9to1v - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux9to1v/#problem-statement","title":"Problem Statement","text":"<p>Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.</p> Tip <p>With this many options, a case statement may be useful.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux9to1v/#official-solution","title":"Official Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/Circuits/ConbinationalLogic/Multiplexers/Mux9to1v/#my-solution","title":"My Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Step_one/","title":"Step_one","text":"<ul> <li>\u6765\u6e90\uff1aStep one - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Step_one/#problem-statement","title":"Problem Statement","text":"<p>We're going to start with a small bit of HDL to get familiar with the interface used by HDLBits. Here's the description of the circuit you need to build for this exercise:</p> <p>Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).</p> Tip <p>We want to assign 1 to the output one.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Step_one/#official-solution","title":"Official Solution","text":"<pre><code>module top_module( output one );\n\n    assign one = 1'b1;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Step_one/#my-solution","title":"My Solution","text":"<pre><code>module top_module( output one );\n\n// Insert your code here\n    assign one = 1;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Step_one/#note","title":"Note","text":"<ul> <li>\u5728\u8d4b\u503c\u7684\u65f6\u5019\u53ef\u4ee5\u5199\u660e\u6570\u503c\u7684\u4f4d\u5bbd\u3001\u57fa\u6570\u548c\u5e38\u91cf\uff0c\u4f8b\u5982\u672c\u9898\u4e2d\u7528<code>1'b1</code>\u66ff\u6362<code>1</code>\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Zero/","title":"Zero","text":"<ul> <li>\u6765\u6e90\uff1aZero - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Zero/#problem-statement","title":"Problem Statement","text":"<p>Build a circuit with no inputs and one output that outputs a constant\u00a00</p> <p>Now that you've worked through the previous problem, let's see if you can do a simple problem without the hints.</p> <p>Note</p> <p>HDLBits uses Verilog-2001 ANSI-style port declaration syntax because it's easier to read and reduces typos. You may use the older Verilog-1995 syntax if you wish. For example, the two module declarations below are acceptable and equivalent: <pre><code>module top_module ( zero );\n    output zero;\n    // Verilog-1995\nendmodule\n</code></pre></p> <pre><code>module top_module ( output zero ); \n\n    // Verilog-2001\nendmodule\n</code></pre> Tip <p>Fun fact: For Quartus synthesis, not assigning a value to a signal usually results in 0. This problem is actually easier than the previous one.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Zero/#official-solution","title":"Official Solution","text":"<pre><code>module top_module ( output zero );\n\n    assign zero = 1'b0;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/GettingStarted/Zero/#my-solution","title":"My Solution","text":"<pre><code>module top_module(\n    output zero\n);// Module body starts after semicolon\n\n    assign zero = 0;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/7485/","title":"7485","text":"<ul> <li>\u6765\u6e90\uff1a7458 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/7485/#problem-statement","title":"Problem Statement","text":"<p>The 7458 is a chip with four AND gates and two OR gates. This problem is slightly more complex than\u00a07420.</p> <p>Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an\u00a0<code>assign</code>\u00a0statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates. For extra practice, try it both ways.</p> <p></p> Tip <p>You need to drive two signals (<code>p1y</code>\u00a0and\u00a0<code>p2y</code>) with a value.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/7485/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( \n    input p1a, p1b, p1c, p1d, p1e, p1f,\n    output p1y,\n    input p2a, p2b, p2c, p2d,\n    output p2y );\n\n    wire ab = p2a &amp; p2b;\n    wire cd = p2c &amp; p2d;\n\n    assign p2y = ab | cd;\n\n    wire abc = p1a &amp; p1b &amp; p1c;\n    wire def = p1d &amp; p1e &amp; p1f;\n\n    assign p1y = abc | def;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Andgate/","title":"Andgate","text":"<ul> <li>\u6765\u6e90\uff1aAndgate - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Andgate/#problem-statement","title":"Problem Statement","text":"<p>Create a module that implements an AND gate.</p> <p>This circuit now has three wires (<code>a</code>,\u00a0<code>b</code>, and\u00a0<code>out</code>). Wires\u00a0<code>a</code>\u00a0and\u00a0<code>b</code>\u00a0already have values driven onto them by the input ports. But wire\u00a0<code>out</code>\u00a0currently is not driven by anything. Write an\u00a0<code>assign</code>\u00a0statement that drives\u00a0<code>out</code>\u00a0with the AND of signals\u00a0<code>a</code>\u00a0and\u00a0<code>b</code>.</p> <p>Note that this circuit is very similar to the\u00a0NOT gate, just with one more input. If it sounds different, it's because I've started describing signals as being\u00a0driven\u00a0(has a known value determined by something attached to it) or\u00a0not driven\u00a0by something.\u00a0<code>Input wires</code>\u00a0are driven by something outside the module.\u00a0<code>assign</code>\u00a0statements will drive a logic level onto a wire. As you might expect, a wire cannot have more than one driver (what is its logic level if there is?), and a wire that has no drivers will have an undefined value (often treated as 0 when synthesizing hardware).</p> Tip <p>Verilog has separate bitwise-AND (&amp;) and logical-AND (&amp;&amp;) operators, like C. Since we're working with a one-bit here, it doesn't matter which we choose.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Andgate/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input a, \n    input b, \n    output out );\n\n    assign out = a &amp;&amp; b;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Norgate/","title":"Norgate","text":"<ul> <li>\u6765\u6e90\uff1aNorgate - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Norgate/#problem-statement","title":"Problem Statement","text":"<p>Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.</p> <p>An\u00a0<code>assign</code>\u00a0statement drives a wire (or \"net\", as it's more formally called) with a value. This value can be as complex a function as you want, as long as it's a\u00a0combinational\u00a0(i.e., memory-less, with no hidden state) function. An\u00a0<code>assign</code>\u00a0statement is a\u00a0continuous assignment\u00a0because the output is \"recomputed\" whenever any of its inputs change, forever, much like a simple logic gate.</p> Tip <p>Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. Since we're working with a one-bit here, it doesn't matter which we choose.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Norgate/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input a, \n    input b, \n    output out );\n\n    assign out = ~(a|b);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Norgate/#note","title":"Note","text":"<ul> <li> <p>\u8fd0\u7b97\u7b26\u662f\u6709\u4f18\u5148\u7ea7\u7684\uff0c\u6700\u5f00\u59cb\u5199\u6210<code>~a|b</code>\uff0c\u5c31\u4e0d\u80fd\u5f97\u5230\u7684\u6b63\u786e\u7684\u7ed3\u679c\uff0c\u56e0\u4e3a\u8fd9\u79cd\u5199\u6cd5\u4f1a\u5148\u8fd0\u7b97<code>~a</code>\uff0c\u518d\u8fd0\u7b97<code>(~a)|b</code></p> </li> <li> <p>\u4e0d\u540c\u64cd\u4f5c\u7b26\u7684\u4f18\u5148\u7ea7\u662f\u4e0d\u540c\u7684\u3002\u5f53\u6ca1\u6709\u5706\u62ec\u53f7\u65f6\uff0cVerilog\u4f1a\u6839\u636e\u64cd\u4f5c\u7b26\u4f18\u5148\u7ea7\u5bf9\u8868\u8fbe\u5f0f\u8fdb\u884c\u8ba1\u7b97</p> </li> <li> <p>\u5728\u4e0d\u786e\u5b9a\u4f18\u5148\u7ea7\u65f6\uff0c\u5efa\u8bae\u7528\u5706\u62ec\u53f7\u5c06\u8868\u8fbe\u5f0f\u533a\u5206\u5f00\u6765</p> </li> </ul> \u64cd\u4f5c\u7b26 \u64cd\u4f5c\u7b26\u53f7 \u4f18\u5148\u7ea7 \u5355\u76ee\u8fd0\u7b97 + - ! ~ \u6700\u9ad8 \u4e58\u3001\u9664\u3001\u53d6\u6a21 * / % \u52a0\u51cf + - \u79fb\u4f4d &lt;&lt; \u00a0&gt;&gt; \u5173\u7cfb &lt;\u00a0 &lt;=\u00a0 &gt;\u00a0 &gt;= \u7b49\u4ef7 ==\u00a0 !=\u00a0 \\===\u00a0 !=== \u5f52\u7ea6 &amp; ~&amp; ^ ~^ |\u00a0~| \u903b\u8f91 &amp;&amp; | \u6761\u4ef6 ?: \u6700\u4f4e"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Notgate/","title":"Notgate","text":"<ul> <li>\u6765\u6e90\uff1aNotgate - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Notgate/#problem-statement","title":"Problem Statement","text":"<p>Create a module that implements a NOT gate.</p> <p>This circuit is similar to\u00a0wire, but with a slight difference. When making the connection from the wire\u00a0<code>in</code>\u00a0to the wire\u00a0<code>out</code>\u00a0we're going to implement an inverter (or \"NOT-gate\") instead of a plain wire.</p> <p>Use an assign statement. The\u00a0<code>assign</code>\u00a0statement will\u00a0continuously\u00a0drive\u00a0the inverse of\u00a0<code>in</code>\u00a0onto wire\u00a0<code>out</code>.</p> <p></p> Tip <p>Verilog has separate bitwise-NOT (~) and logical-NOT (!) operators, like C. Since we're working with a one-bit here, it doesn't matter which we choose.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Notgate/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input in,\n    output out\n);\n\n    assign out = ~in;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Notgate/#my-solution","title":"My Solution","text":"<pre><code>module top_module( input in, output out );\n\n    assign out = ~in;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire/","title":"Wire","text":"<ul> <li>\u6765\u6e90\uff1aWire - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire/#problem-statement","title":"Problem Statement","text":"<p>Create a module with one input and one output that behaves like a wire.</p> <p>Unlike physical wires, wires (and other signals) in Verilog are\u00a0directional. This means information flows in only one direction, from (usually one)\u00a0source\u00a0to the\u00a0sinks\u00a0(The source is also often called a\u00a0driver\u00a0that\u00a0drives\u00a0a value onto a wire). In a Verilog \"continuous assignment\" (<code>assign left_side = right_side;</code>), the value of the signal on the right side is driven onto the wire on the left side. The assignment is \"continuous\" because the assignment continues all the time even if the right side's value changes. A continuous assignment is not a one-time event.</p> <p>The ports on a module also have a direction (usually input or output). An input port is\u00a0driven by\u00a0something from outside the module, while an output port\u00a0drives\u00a0something outside. When viewed from inside the module, an input port is a driver or source, while an output port is a sink.</p> <p>The diagram below illustrates how each part of the circuit corresponds to each bit of Verilog code. The module and port declarations create the black portions of the circuit. Your task is to create a wire (in green) by adding an\u00a0<code>assign</code>\u00a0statement to connect\u00a0<code>in</code>\u00a0to\u00a0<code>out</code>. The parts outside the box are not your concern, but you should know that your circuit is tested by connecting signals from our test harness to the ports on your\u00a0<code>top_module</code>.</p> <p></p> <p>In addition to continuous assignments, Verilog has three other assignment types that are used in procedural blocks, two of which are synthesizable. We won't be using them until we start using procedural blocks.</p> Tip <p>A continuous assignment assigns the right side to the left side continuously, so any change to the RHS is immediately seen in the LHS.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire/#official-solution","title":"Official Solution","text":"<pre><code>module top_module( input in, output out );\n\n    assign out = in;\n    // Note that wires are directional, so \"assign in = out\" is not equivalent.\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire/#my-solution","title":"My Solution","text":"<pre><code>module top_module( input in, output out );\n\n    assign out = in;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire4/","title":"Wire4","text":"<ul> <li>\u6765\u6e90\uff1aWire4 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire4/#problem-statement","title":"Problem Statement","text":"<p>Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:</p> <p>a -&gt; w b -&gt; x b -&gt; y c -&gt; z The diagram below illustrates how each part of the circuit corresponds to each bit of Verilog code. From outside the module, there are three input ports and four output ports.</p> <p>When you have multiple assign statements, the order in which they appear in the code does not matter. Unlike a programming language, assign statements (\"continuous assignments\") describe connections between things, not the action of copying a value from one thing to another.</p> <p>One potential source of confusion that should perhaps be clarified now: The green arrows here represent connections between wires, but are not wires in themselves. The module itself already has 7 wires declared (named a, b, c, w, x, y, and z). This is because input and output declarations actually declare a wire unless otherwise specified. Writing input wire a is the same as input a. Thus, the assign statements are not creating wires, they are creating the connections between the 7 wires that already exist.</p> Tip <p>The concatenation operator { signal1, signal2, signal3, ... } would be useful here.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire4/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\n    // If we're certain about the width of each signal, using \n    // the concatenation operator is equivalent and shorter:\n    // assign {w,x,y,z} = {a,b,b,c};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire4/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input a,b,c,\n    output w,x,y,z );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire_decl/","title":"Wire decl","text":"<ul> <li>\u6765\u6e90\uff1aWire decl - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire_decl/#problem-statement","title":"Problem Statement","text":"<p>The circuits so far have been simple enough that the outputs are simple functions of the inputs. As circuits become more complex, you will need wires to connect internal components together. When you need to use a wire, you should declare it in the body of the module, somewhere before it is first used. (In the future, you will encounter more types of signals and variables that are also declared the same way, but for now, we'll start with a signal of type\u00a0wire).</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire_decl/#example","title":"Example","text":"<pre><code>module top_module (\n    input in,              // Declare an input wire named \"in\"\n    output out             // Declare an output wire named \"out\"\n);\n\n    wire not_in;           // Declare a wire named \"not_in\"\n\n    assign out = ~not_in;  // Assign a value to out (create a NOT gate).\n    assign not_in = ~in;   // Assign a value to not_in (create another NOT gate).\n\nendmodule   // End of module \"top_module\"\n</code></pre> <p>In the above module, there are three wires (in,\u00a0out, and\u00a0not_in), two of which are already declared as part of the module's input and output ports (This is why you didn't need to declare any wires in the earlier exercises). The wire\u00a0not_in\u00a0needs to be declared inside the module. It is not visible from outside the module. Then, two NOT gates are created using two\u00a0assign\u00a0statements. Note that it doesn't matter which of the NOT gates you create first: You still end up with the same circuit.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire_decl/#practice","title":"Practice","text":"<p>Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire\u00a0out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.</p> <p>If you're following the circuit structure in the diagram, you should end up with four assign statements, as there are four signals that need a value assigned.</p> <p>(Yes, it is possible to create a circuit with the same functionality without the intermediate wires.)</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire_decl/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    wire w1, w2;        // Declare two wires (named w1 and w2)\n    assign w1 = a&amp;b;    // First AND gate\n    assign w2 = c&amp;d;    // Second AND gate\n    assign out = w1|w2; // OR gate: Feeds both 'out' and the NOT gate\n\n    assign out_n = ~out;    // NOT gate\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Wire_decl/#my-solution","title":"My Solution","text":"<pre><code>`default_nettype none\nmodule top_module(\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n   );\n\n    wire wire_ab = a&amp;b;\n    wire wire_cd = c&amp;d;\n    wire result = wire_ab | wire_cd;\n\n    assign out = result;\n    assign out_n = ~result;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Xnorgate/","title":"Xnorgate","text":"<ul> <li>\u6765\u6e90\uff1aXnorgate - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Xnorgate/#problem-statement","title":"Problem Statement","text":"<p>Create a module that implements an XNOR gate.</p> Tip <p>The bitwise-XOR operator is ^. There is no logical-XOR operator.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Xnorgate/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input a, \n    input b, \n    output out );\n\n    assign out = ~(a^b);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Basics/Xnorgate/#note","title":"Note","text":"<ul> <li> <p>XOR\u662f\u5f02\u6216\u95e8\uff0c\u8f93\u51fa\u5728\u8f93\u5165\u4e0d\u540c\u65f6\u4e3a1\uff0c\u5728\u8f93\u5165\u76f8\u540c\u65f6\u4e3a0</p> </li> <li> <p>XNOR\u662f\u540c\u6216\u95e8\uff0c\u8f93\u51fa\u5728\u8f93\u5165\u76f8\u540c\u65f6\u4e3a1\uff0c\u5728\u8f93\u5165\u4e0d\u540c\u65f6\u4e3a0</p> </li> <li> <p>Verilog\u6ca1\u6709XNOR\u8fd0\u7b97\u7b26\uff0c\u6240\u4ee5\u540c\u6216\u8fd0\u7b97\u662f\u5728\u5f02\u6216\u8fd0\u7b97\u7b26<code>^</code>\u7684\u57fa\u7840\u4e0a\u53d6\u53cd</p> </li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module%20fadd/","title":"Module fadd","text":"<ul> <li>\u6765\u6e90\uff1aModule fadd - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module%20fadd/#problem-statement","title":"Problem Statement","text":"<p>In this exercise, you will create a circuit with two levels of hierarchy. Your\u00a0<code>top_module</code>\u00a0will instantiate two copies of\u00a0<code>add16</code>\u00a0(provided), each of which will instantiate 16 copies of\u00a0<code>add1</code>\u00a0(which you must write). Thus, you must write\u00a0two\u00a0modules:\u00a0<code>top_module</code>\u00a0and\u00a0<code>add1</code>.</p> <p>Like\u00a0module_add, you are given a module\u00a0<code>add16</code>\u00a0that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. One\u00a0<code>add16</code>\u00a0module computes the lower 16 bits of the addition result, while the second\u00a0<code>add16</code>\u00a0module computes the upper 16 bits of the result. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).</p> <p>Connect the\u00a0<code>add16</code>\u00a0modules together as shown in the diagram below. The provided module\u00a0<code>add16</code>\u00a0has the following declaration: <pre><code>module add16 ( \n    input[15:0]\u00a0a, \n    input[15:0]\u00a0b, \n    input\u00a0cin, \n    output[15:0]\u00a0sum, \n    output\u00a0cout\u00a0\n);\n</code></pre></p> <p>Within each\u00a0<code>add16</code>, 16 full adders (module\u00a0<code>add1</code>, not provided) are instantiated to actually perform the addition. You must write the full adder module that has the following declaration: <pre><code>module add1 ( input a, input b, input cin, output sum, output cout );\n</code></pre></p> <p>Recall that a full adder computes the sum and carry-out of a+b+cin.</p> <p>In summary, there are three modules in this design:</p> <ul> <li><code>top_module</code>\u00a0\u2014 Your top-level module that contains two of...</li> <li><code>add16</code>, provided \u2014 A 16-bit adder module that is composed of 16 of...</li> <li><code>add1</code>\u00a0\u2014 A 1-bit full adder module.</li> </ul> <p>If your submission is missing a\u00a0<code>module add1</code>, you will get an error message that says\u00a0<code>Error (12006): Node instance \"user_fadd[0].a1\" instantiates undefined entity \"add1\"</code>.</p> <p></p> Tip <p>Full adder equations: sum = a ^ b ^ cin cout = a&amp;b | a&amp;cin | b&amp;cin</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module%20fadd/#official-solution","title":"Official Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module%20fadd/#my-solution","title":"My Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module%20fadd/#_1","title":"\u672a\u5b8c\u6210","text":"<pre><code>module top_module (\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);//\n    wire [16:0] carry;\n    assign carry[0] = 1'b0;\n    reg [15:0] sum1;\n    reg [15:0] sum2;\n    wire cout;\n    genvar i;\n    generate\n        for (i = 0; i &lt; 16; i = i + 1) begin: adder_loop\n            add1 adder (\n                .a(a[i]),\n                .b(b[i]),\n                .cin(carry[i]),\n                .sum(sum1[i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n\n    assign cout = carry[16];\n\n    add16 u_add16(\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .cin(cout),\n        .cout(),\n        .sum(sum2)\n    );\n\n    assign sum = {sum2, sum1};\n\n\nendmodule\n\nmodule add1 ( input a, input b, input cin,   output sum, output cout );\n\n    // Full adder module here\n    assign sum = a ^ b ^ cin;\n    assign cout = a &amp; b | a &amp; cin | b &amp; cin;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/","title":"Module","text":"<ul> <li>\u6765\u6e90\uff1aModule - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/#problem-statement","title":"Problem Statement","text":"<p>By now, you're familiar with a\u00a0<code>module</code>, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by\u00a0composing\u00a0bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.</p> <p>The figure below shows a very simple circuit with a sub-module. In this exercise, create one\u00a0instance\u00a0of module\u00a0<code>**mod_a**</code>, then connect the module's three pins (<code>in1</code>,\u00a0<code>in2</code>, and\u00a0<code>out</code>) to your top-level module's three ports (wires\u00a0<code>a</code>,\u00a0<code>b</code>, and\u00a0<code>out</code>). The module\u00a0<code>mod_a</code>\u00a0is provided for you \u2014 you must instantiate it.</p> <p>When connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module\u00a0<code>mod_a</code>\u00a0looks like this:</p> <p></p> <p>module mod_a ( input in1, input in2, output out );     // Module body endmodule</p> <p>The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written\u00a0inside\u00a0another module's body (Code for different modules are not nested).</p> <p>You may connect signals to the module by port name or port position. For extra practice, try both methods.</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/#connecting-signals-to-module-ports","title":"Connecting Signals to Module Ports","text":"<p>There are two commonly-used methods to connect a wire to a port: by position or by name.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/#by-position","title":"By position","text":"<p>The syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module's declaration. For example:</p> <p><code>mod_a instance1 ( wa, wb, wc );</code></p> <p>This instantiates a module of type\u00a0<code>mod_a</code>\u00a0and gives it an\u00a0instance name\u00a0of \"instance1\", then connects signal\u00a0<code>wa</code>\u00a0(outside the new module) to the\u00a0first\u00a0port (<code>in1</code>) of the new module,\u00a0<code>wb</code>\u00a0to the\u00a0second\u00a0port (<code>in2</code>), and\u00a0<code>wc</code>\u00a0to the\u00a0third\u00a0port (<code>out</code>). One drawback of this syntax is that if the module's port list changes, all instantiations of the module will also need to be found and changed to match the new module.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/#by-name","title":"By name","text":"<p>Connecting signals to a module's ports\u00a0by name\u00a0allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.</p> <p><code>mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );</code></p> <p>The above line instantiates a module of type\u00a0<code>mod_a</code>\u00a0named \"instance2\", then connects signal\u00a0<code>wa</code>\u00a0(outside the module) to the port\u00a0named <code>in1</code>,\u00a0<code>wb</code>\u00a0to the port\u00a0named <code>in2</code>, and\u00a0<code>wc</code>\u00a0to the port\u00a0named <code>out</code>. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module's port list. Also notice the period immediately preceding the port name in this syntax.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input a,\n    input b,\n    output out\n);\n\n    // Create an instance of \"mod_a\" named \"inst1\", and connect ports by name:\n    mod_a inst1 ( \n        .in1(a),    // Port\"in1\"connects to wire \"a\"\n        .in2(b),    // Port \"in2\" connects to wire \"b\"\n        .out(out)   // Port \"out\" connects to wire \"out\" \n                // (Note: mod_a's port \"out\" is not related to top_module's wire \"out\". \n                // It is simply coincidence that they have the same name)\n    );\n\n/*\n    // Create an instance of \"mod_a\" named \"inst2\", and connect ports by position:\n    mod_a inst2 ( a, b, out );  // The three wires are connected to ports in1, in2, and out, respectively.\n*/\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( input a, input b, output out );\n\n    mod_a u_mod_a(\n        .in1(a),\n        .in2(b),\n        .out(out)\n    );\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_add/","title":"Module add","text":"<ul> <li>\u6765\u6e90\uff1aModule add - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_add/#problem-statement","title":"Problem Statement","text":"<p>You are given a module\u00a0<code>add16</code>\u00a0that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the\u00a0<code>add16</code>\u00a0module performs 16-bit a + b + cin, while your module performs 32-bit a + b).</p> <p>Connect the modules together as shown in the diagram below. The provided module\u00a0<code>add16</code>\u00a0has the following declaration: <pre><code>module add16 ( \n    input[15:0]\u00a0a, \n    input[15:0]\u00a0b, \n    input\u00a0cin, \n    output[15:0]\u00a0sum, \n    output\u00a0cout\u00a0\n);\n</code></pre></p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_add/#my-solution","title":"My Solution","text":"<pre><code>module top_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\n    reg [15:0] sum1;\n    reg [15:0] sum2;\n    reg count;\n\n    add16 u_add16_1(\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .cin(1'b0),\n        .sum(sum1),\n        .cout(count)\n    );\n\n    add16 u_add16_2(\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .cin(count),\n        .sum(sum2),\n        .cout()\n    );\n\n    assign sum = {sum2, sum1};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_name/","title":"Module name","text":"<ul> <li>\u6765\u6e90\uff1aModule name - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_name/#problem-statement","title":"Problem Statement","text":"<p>This problem is similar to\u00a0module. You are given a module named\u00a0<code>mod_a</code>\u00a0that has 2 outputs and 4 inputs, in some order. You must connect the 6 ports\u00a0by name\u00a0to your top-level module's ports:</p> Port in\u00a0<code>**mod_a**</code> Port in\u00a0<code>**top_module**</code> <code>output out1</code> <code>out1</code> <code>output out2</code> <code>out2</code> <code>input in1</code> <code>a</code> <code>input in2</code> <code>b</code> <code>input in3</code> <code>c</code> <code>input in4</code> <code>d</code> <p>You are given the following module:</p> <p><code>module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);</code></p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_name/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( \n    input a, \n    input b, \n    input c,\n    input d,\n    output out1,\n    output out2\n);\n\n    mod_a u_mod_a(\n        .out1(out1),\n        .out2(out2),\n        .in1(a),\n        .in2(b),\n        .in3(c),\n        .in4(d)\n    );\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_name/#note","title":"Note","text":"<ul> <li>\u8fd9\u4e00\u8282\u4e3b\u8981\u7ec3\u4e60\u6a21\u5757\u7684\u4f8b\u5316\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_pos/","title":"Module pos","text":"<ul> <li>\u6765\u6e90\uff1aModule pos - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_pos/#problem-statement","title":"Problem Statement","text":"<p>This problem is similar to the previous one (module). You are given a module named\u00a0<code>mod_a</code>\u00a0that has 2 outputs and 4 inputs, in that order. You must connect the 6 ports\u00a0by position\u00a0to your top-level module's ports\u00a0<code>out1</code>,\u00a0<code>out2</code>,\u00a0<code>a</code>,\u00a0<code>b</code>,\u00a0<code>c</code>, and\u00a0<code>d</code>, in that order.</p> <p>You are given the following module:</p> <pre><code>module mod_a ( output, output, input, input, input, input );\n</code></pre> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_pos/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( \n    input a, \n    input b, \n    input c,\n    input d,\n    output out1,\n    output out2\n);\n\n    mod_a u_mod_a(out1, out2, a, b, c, d);\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift/","title":"Module shift","text":"<ul> <li>\u6765\u6e90\uff1aModule shift - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift/#problem-statement","title":"Problem Statement","text":"<p>You are given a module\u00a0<code>my_dff</code>\u00a0with two inputs and one output (that implements a D flip-flop). Instantiate three of them, then chain them together to make a shift register of length 3. The\u00a0<code>clk</code>\u00a0port needs to be connected to all instances.</p> <p>The module provided to you is:\u00a0<code>module my_dff ( input clk, input d, output q );</code></p> <p>Note that to make the internal connections, you will need to declare some wires. Be careful about naming your wires and module instances: the names must be unique.</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input clk,\n    input d,\n    output q\n);\n\n    wire a, b;  // Create two wires. I called them a and b.\n\n    // Create three instances of my_dff, with three different instance names (d1, d2, and d3).\n    // Connect ports by position: ( input clk, input d, output q)\n    my_dff d1 ( clk, d, a );\n    my_dff d2 ( clk, a, b );\n    my_dff d3 ( clk, b, q );\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( input clk, input d, output q );\n\n    wire q1,q2;\n    my_dff u_my_dff_1( \n        .clk(clk),\n        .d(d),\n        .q(q1)\n    );\n\n    my_dff u_my_dff_2( \n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    my_dff u_my_dff_3( \n        .clk(clk),\n        .d(q2),\n        .q(q)\n    );\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift/#note","title":"Note","text":"<ul> <li>\u5982\u662f\u91c7\u7528\u6839\u636e\u540d\u79f0\u8fdb\u884c\u4f8b\u5316\uff0c\u50cf\u8fd9\u79cd\u9700\u8981\u4f8b\u5316\u5f88\u591a\u4e2a\u6a21\u5757\u7684\u60c5\u51b5\uff0c\u5c31\u5f88\u7e41\u7410\uff0c\u6709\u6ca1\u6709\u5feb\u6377\u7684\u65b9\u6cd5\uff1f\u6bd4\u5982\u8fd9\u9053\u9898\u4f7f\u7528\u6839\u636e\u4f4d\u7f6e\u8fdb\u884c\u4f8b\u5316\uff1f\u6bd4\u5982\u8ba9AI\u8fdb\u884c\u4f8b\u5316\uff1f</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift8/","title":"Module shift8","text":"<ul> <li>\u6765\u6e90\uff1aModule shift8 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift8/#problem-statement","title":"Problem Statement","text":"<p>This exercise is an extension of\u00a0module_shift. Instead of module ports being only single pins, we now have modules with vectors as ports, to which you will attach wire vectors instead of plain wires. Like everywhere else in Verilog, the vector length of the port does not have to match the wire connecting to it, but this will cause zero-padding or trucation of the vector. This exercise does not use connections with mismatched vector lengths.</p> <p>You are given a module\u00a0<code>my_dff8</code>\u00a0with two inputs and one output (that implements a set of 8 D flip-flops). Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on\u00a0<code>sel[1:0]</code>: The value at the input d, after the first, after the second, or after the third D flip-flop. (Essentially,\u00a0<code>sel</code>\u00a0selects how many cycles to delay the input, from zero to three clock cycles.)</p> <p>The module provided to you is:\u00a0<code>module my_dff8 ( input clk, input [7:0] d, output [7:0] q );</code></p> <p>The multiplexer is not provided. One possible way to write one is inside an\u00a0<code>always</code>\u00a0block with a\u00a0<code>case</code>\u00a0statement inside. (See also:\u00a0mux9to1v)</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift8/#official-solution","title":"Official Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift8/#my-solution","title":"My Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Module%EF%BC%9AHierarchy/Module_shift8/#note","title":"Note","text":"<ul> <li>\u8fd9\u9053\u9898\u4f1a\u7528\u5230\u540e\u9762\u7684\u77e5\u8bc6\uff0c\u53ef\u4ee5\u5148\u8df3\u8fc7\uff0c\u7b49\u5b8c\u6210\u540e\u9762\u7684\u7ec3\u4e60\u518d\u505a\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Gates4/","title":"Gates4","text":"<ul> <li>\u6765\u6e90\uff1aGates4 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Gates4/#problem-statement","title":"Problem Statement","text":"<p>Build a combinational circuit with four inputs,\u00a0in[3:0].</p> <p>There are 3 outputs:</p> <ul> <li>out_and: output of a 4-input AND gate.</li> <li>out_or: output of a 4-input OR gate.</li> <li>out_xor: output of a 4-input XOR gate.</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Gates4/#official-solution","title":"Official Solution","text":""},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Gates4/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = in[0] &amp; in[1] &amp; in[2] &amp; in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector0/","title":"Vector0","text":"<ul> <li>\u6765\u6e90\uff1aVector0 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector0/#problem-statement","title":"Problem Statement","text":"<p>Vectors are used to group related signals using one name to make it more convenient to manipulate. For example,\u00a0wire [7:0] w;\u00a0declares an 8-bit vector named\u00a0w\u00a0that is functionally equivalent to having 8 separate wires.</p> <p>Notice that the\u00a0declaration\u00a0of a vector places the dimensions\u00a0before\u00a0the name of the vector, which is unusual compared to C syntax. However, the\u00a0part select\u00a0has the dimensions\u00a0after\u00a0the vector name as you would expect.</p> <pre><code>wire [99:0] my_vector; // Declare a 100-element vector \nassign out = my_vector[10]; // Part-select one bit out of the vector\n</code></pre> <p>Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output\u00a0<code>o0</code>\u00a0to the input vector's position 0,\u00a0<code>o1</code>\u00a0to position 1, etc.</p> <p>In a diagram, a tick mark with a number next to it indicates the width of the vector (or \"bus\"), rather than drawing a separate line for each bit in the vector.</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector0/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n\n    // This is ok too: assign {o2, o1, o0} = vec;\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector0/#my-solution","title":"My Solution","text":"<pre><code>module top_module ( \n    input wire [2:0] vec,\n    output wire [2:0] outv,\n    output wire o2,\n    output wire o1,\n    output wire o0  ); // Module body starts after module declaration\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/","title":"Vector1","text":"<ul> <li>\u6765\u6e90\uff1aVector1 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#problem-statement","title":"Problem Statement","text":"<p>Vectors are used to group related signals using one name to make it more convenient to manipulate. For example,\u00a0wire [7:0] w;\u00a0declares an 8-bit vector named\u00a0w\u00a0that is equivalent to having 8 separate wires.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#declaring-vectors","title":"Declaring Vectors","text":"<p>Vectors must be declared:</p> <p>type [upper:lower] vector_name;</p> <p>type\u00a0specifies the datatype of the vector. This is usually\u00a0wire\u00a0or\u00a0reg. If you are declaring a input or output port, the type can additionally include the port type (e.g.,\u00a0input\u00a0or\u00a0output) as well. Some examples: <pre><code>wire [7:0] w;         // 8-bit wire\nreg  [4:1] x;         // 4-bit reg\noutput reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)\ninput wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)\noutput [3:0] a;       // 4-bit output wire. Type is 'wire' unless specified otherwise.\nwire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.\n</code></pre></p> <p>The\u00a0endianness\u00a0(or, informally, \"direction\") of a vector is whether the the least significant bit has a lower index (little-endian, e.g., [3:0]) or a higher index (big-endian, e.g., [0:3]). In Verilog, once a vector is declared with a particular endianness, it must always be used the same way. e.g., writing\u00a0<code>vec[0:3]</code>\u00a0when\u00a0<code>vec</code>\u00a0is declared\u00a0<code>wire [3:0] vec;</code>\u00a0is illegal. Being consistent with endianness is good practice, as weird bugs occur if vectors of different endianness are assigned or used together.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#implicit-nets","title":"Implicit nets","text":"<p>Implicit nets are often a source of hard-to-detect bugs. In Verilog, net-type signals can be implicitly created by an\u00a0<code>assign</code>\u00a0statement or by attaching something undeclared to a module port. Implicit nets are always one-bit wires and causes bugs if you had intended to use a vector. Disabling creation of implicit nets can be done using the\u00a0<code>`default_nettype none</code>\u00a0directive. <pre><code>wire [2:0] a, c; // Two vectors \nassign a = 3'b101; // a = 101 \nassign b = a; // b = 1 implicitly-created wire \nassign c = b; // c = 001 &lt;-- bug \nmy_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.   \n                    // This could be a bug if the port was intended to be a vector.\n</code></pre> Adding\u00a0<code>default_nettype</code> none would make the second line of code an error, which makes the bug more visible.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#unpacked-vs-packed-arrays","title":"Unpacked vs. Packed Arrays","text":"<p>You may have noticed that in\u00a0declarations, the vector indices are written\u00a0before\u00a0the vector name. This declares the \"packed\" dimensions of the array, where the bits are \"packed\" together into a blob (this is relevant in a simulator, but not in hardware). The\u00a0unpacked\u00a0dimensions are declared\u00a0after\u00a0the name. They are generally used to declare memory arrays. Since ECE253 didn't cover memory arrays, we have not used packed arrays in this course. See\u00a0http://www.asic-world.com/systemverilog/data_types10.html\u00a0for more details. <pre><code>reg [7:0] mem [255:0];   // 256 unpacked elements, each of which is a 8-bit packed vector of reg.\nreg mem2 [28:0];         // 29 unpacked elements, each of which is a 1-bit reg.\n</code></pre></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#accessing-vector-elements-part-select","title":"Accessing Vector Elements: Part-Select","text":"<p>Accessing an entire vector is done using the vector name. For example:</p> <p>assign w = a;</p> <p>takes the entire 4-bit vector\u00a0a\u00a0and assigns it to the entire 8-bit vector\u00a0w\u00a0(declarations are taken from above). If the lengths of the right and left sides don't match, it is zero-extended or truncated as appropriate.</p> <p>The part-select operator can be used to access a portion of a vector: <pre><code>w[3:0]      // Only the lower 4 bits of w\nx[1]        // The lowest bit of x\nx[1:1]      // ...also the lowest bit of x\nz[-1:-2]    // Two lowest bits of z\nb[3:0]      // Illegal. Vector part-select must match the direction of the declaration.\nb[0:3]      // The *upper* 4 bits of b.\nassign w[3:0] = b[0:3];    // Assign upper 4 bits of b to lower 4 bits of w. w[3]=b[0], w[2]=b[1], etc.\n</code></pre></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#a-bit-of-practice","title":"A Bit of Practice","text":"<p>Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\n    // Concatenation operator also works: assign {out_hi, out_lo} = in;\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector1/#my-solution","title":"My Solution","text":"<pre><code>`default_nettype none     // Disable implicit nets. Reduces some types of bugs.\nmodule top_module( \n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo );\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector2/","title":"Vector2","text":"<ul> <li>\u6765\u6e90\uff1aVector2 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector2/#problem-statement","title":"Problem Statement","text":"<p>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the\u00a0byte\u00a0ordering of the 4-byte word.</p> <p>AaaaaaaaBbbbbbbbCcccccccDddddddd =&gt; DdddddddCcccccccBbbbbbbbAaaaaaaa</p> <p>This operation is often used when the\u00a0endianness\u00a0of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols.</p> Tip <p>Part-select can be used on both the left side and right side of an assignment.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector2/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out[31:24] = in[ 7: 0];  \n    assign out[23:16] = in[15: 8];  \n    assign out[15: 8] = in[23:16];  \n    assign out[ 7: 0] = in[31:24];  \n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector2/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [31:0] in,\n    output [31:0] out );//\n\n    // assign out[31:24] = ...;\n    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector2/#note","title":"Note","text":"<ul> <li>\u8fd9\u9053\u9898\u4f7f\u7528\u62fc\u63a5\u7b26<code>{}</code>\u5c31\u5f88\u65b9\u4fbf\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector3/","title":"Vector3","text":"<ul> <li>\u6765\u6e90\uff1aVector3 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector3/#problem-statement","title":"Problem Statement","text":"<p>Part selection\u00a0was used to select portions of a vector. The concatenation operator\u00a0{a,b,c}\u00a0is used to create larger vectors by concatenating smaller portions of a vector together.</p> <pre><code>{3'b111, 3'b000} =&gt; 6'b111000\n{1'b1, 1'b0, 3'b101} =&gt; 5'b10101\n{4'ha, 4'd10} =&gt; 8'b10101010     // 4'ha and 4'd10 are both 4'b1010 in binary\n</code></pre> <p>Concatenation needs to know the width of every component (or how would you know the length of the result?). Thus,\u00a0{1, 2, 3}\u00a0is illegal and results in the error message:\u00a0unsized constants are not allowed in concatenations.</p> <p>The concatenation operator can be used on both the left and right sides of assignments.</p> <pre><code>input [15:0] in;\noutput [23:0] out;\nassign {out[7:0], out[15:8]} = in;         // Swap two bytes. Right side and left side are both 16-bit vectors.\nassign out[15:0] = {in[7:0], in[15:8]};    // This is the same thing.\nassign out = {in[7:0], in[15:8]};       // This is different. The 16-bit vector on the right is extended to\n                                        // match the 24-bit vector on the left, so out[23:16] are zero.\n                                        // In the first two examples, out[23:16] are not assigned.\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector3/#a-bit-of-practice","title":"A Bit of Practice","text":"<p>Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two\u00a01\u00a0bits:</p> <p></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector3/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input [4:0] a, b, c, d, e, f,\n    output [7:0] w, x, y, z );//\n\n    // assign { ... } = { ... };\n    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector3/#note","title":"Note","text":"<ul> <li> <p>\u8f93\u5165\u7684\u4f4d\u6570\u53ea\u670930\u4f4d\uff0c\u8f93\u51fa\u7684\u4f4d\u6570\u670932\u4f4d\uff0c\u6240\u4ee5\u9700\u8981\u8f93\u5165\u5728\u672b\u5c3e\u589e\u52a0\u4e24\u4f4d<code>2'b11</code>\u3002</p> </li> <li> <p>\u8fd0\u884c\u7ed3\u679c\u51fa\u73b0\u8b66\u544a\uff1a <pre><code>Warning (13024): Output pins are stuck at VCC or GND\n\nThis warning says that an output pin never changes (is \"stuck\"). This can sometimes indicate a bug if the output pin shouldn't be a constant. If this pin is not supposed to be constant, check for bugs that cause the value being assigned to never change (e.g.,\u00a0assign a = x &amp; ~x;)\n</code></pre></p> </li> </ul> <p>\u8868\u660e\u67d0\u4e9b\u8f93\u51fa\u5f15\u811a\u59cb\u7ec8\u4fdd\u6301\u5728VCC(\u9ad8\u7535\u5e73)\u6216GND(\u4f4e\u7535\u5e73)\u72b6\u6001\uff0c\u4ece\u672a\u53d8\u5316\u3002</p> <p>\u5ffd\u7565\u6389\u8fd9\u4e2a\u8b66\u544a\u3002</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector4/","title":"Vector4","text":"<ul> <li>\u6765\u6e90\uff1aVector4 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector4/#problem-statement","title":"Problem Statement","text":"<p>The\u00a0concatenation operator\u00a0allowed concatenating together vectors to form a larger vector. But sometimes you want the same thing concatenated together many times, and it is still tedious to do something like\u00a0assign a = {b,b,b,b,b,b};. The replication operator allows repeating a vector and concatenating them together:</p> <p>{num{vector}}</p> <p>This replicates\u00a0vector\u00a0by\u00a0num\u00a0times.\u00a0num\u00a0must be a constant. Both sets of braces are required.</p> <p>Examples: <pre><code>{5{1'b1}}           // 5'b11111 (or 5'd31 or 5'h1f)\n{2{a,b,c}}          // The same as {a,b,c,a,b,c}\n{3'd5, {2{3'd6}}}   // 9'b101_110_110. It's a concatenation of 101 with\n                    // the second vector, which is two copies of 3'b110.\n</code></pre></p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector4/#a-bit-of-practice","title":"A Bit of Practice","text":"<p>One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending\u00a04'b0101\u00a0(5) to 8 bits results in\u00a08'b00000101\u00a0(5), while sign-extending\u00a04'b1101\u00a0(-3) to 8 bits results in\u00a08'b11111101\u00a0(-3).</p> <p>Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector4/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    // Concatenate two things together:\n    // 1: {in[7]} repeated 24 times (24 bits)\n    // 2: in[7:0] (8 bits)\n    assign out = { {24{in[7]}}, in };\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector4/#my-solution","title":"My Solution","text":"<pre><code>module top_module (\n    input [7:0] in,\n    output [31:0] out );//\n\n    // assign out = { replicate-sign-bit , the-input };\n    assign out = { in[7] ? {24{1'b1}} : {24{1'b0}} , in };\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector4/#note","title":"Note","text":"<ul> <li>\u6700\u5f00\u59cb\u4f7f\u7528\u7684\u662fif\u8bed\u53e5\uff0c\u7ed3\u679c\u4e00\u76f4\u90fd\u65e0\u6cd5\u7f16\u8bd1\u901a\u8fc7\uff0c\u4e00\u76f4\u62a5\u9519\uff1a <pre><code>Error (10759): Verilog HDL error at top_module.v(7): object in declared in a list of port declarations cannot be redeclared within the module body File: /home/h/work/hdlbits.5429460/top_module.v Line: 7\n</code></pre></li> <li>\u5728\u6c42\u6559\uff0cverilog\u91cc\u9762\u80fd\u5728if\u8bed\u53e5\u4e2d\u4f7f\u7528assign\u5417 - \u6570\u5b57IC\u8bbe\u8ba1\u8ba8\u8bba(IC\u524d\u7aef|FPGA|ASIC) - EETOP \u521b\u82af\u7f51\u8bba\u575b (\u539f\u540d\uff1a\u7535\u5b50\u9876\u7ea7\u5f00\u53d1\u7f51) -\u53d1\u73b0\u6709\u4eba\u8bf4\uff1a<ul> <li>verilog \u4e2d\u53ef\u7efc\u5408\u7684\u53ea\u6709always \u548c assign\u4e24\u79cd\u8bed\u53e5\uff0cif else\u53ea\u80fd\u7528\u5728always\u8bed\u53e5\u5757\u91cc\u9762\u3002</li> <li>assign \u7528\u4e8e\u8fde\u7eed\u8d4b\u503c\u8bed\u53e5\uff0cif-else\u7528\u4e8eRTL\u7ea7\u63cf\u8ff0\u4e2d\uff0c\u88ab\u8d4b\u503c\u7684\u53d8\u91cf\u90fd\u662freg\u7c7b\u578b\u3002  </li> <li>reg\u7c7b\u578b\u8d4b\u503c\u5206blocked\u548cnonblocked\uff0c\u5373=\u548c&lt;=\uff0c\u4e0d\u9700\u8981\u518d\u4f7f\u7528assign</li> </ul> </li> <li>\u6240\u4ee5\u6700\u540e\u4f7f\u7528\u7684\u662f<code>?:</code>\u8bed\u53e5\u3002</li> <li>\u6211\u7684\u4ee3\u7801\u6bd4\u8f83\u5197\u4f59\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector5/","title":"Vector5","text":"<ul> <li>\u6765\u6e90\uff1aVector5 - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector5/#problem-statement","title":"Problem Statement","text":"<p>Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. <pre><code>out[24] = ~a ^ a;   // a == a, so out[24] is always 1.\nout[23] = ~a ^ b;\nout[22] = ~a ^ c;\n...\nout[ 1] = ~e ^ d;\nout[ 0] = ~e ^ e;\n</code></pre></p> <p></p> <p>As the diagram shows, this can be done more easily using the\u00a0replication\u00a0and concatenation operators.</p> <ul> <li>The top vector is a concatenation of 5 repeats of each input</li> <li>The bottom vector is 5 repeats of a concatenation of the 5 inputs</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector5/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input a, b, c, d, e,\n    output [24:0] out\n);\n\n    wire [24:0] top, bottom;\n    assign top    = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };\n    assign bottom = {5{a,b,c,d,e}};\n    assign out = ~top ^ bottom; // Bitwise XNOR\n\n    // This could be done on one line:\n    // assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vector5/#note","title":"Note","text":"<ul> <li>\u8fd9\u9053\u9898\u76ee\u6ca1\u6709\u505a\u51fa\u6765\u3002</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorgates/","title":"Vectorgates","text":"<ul> <li>\u6765\u6e90\uff1aVectorgates - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorgates/#problem-statement","title":"Problem Statement","text":"<p>Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of\u00a0<code>b</code>\u00a0in the upper half of\u00a0<code>out_not</code>\u00a0(i.e., bits [5:3]), and the inverse of\u00a0<code>a</code>\u00a0in the lower half.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorgates/#bitwise-vs-logical-operators","title":"Bitwise vs. Logical Operators","text":"<p>Earlier, we mentioned that there are bitwise and logical versions of the various boolean operators (e.g.,\u00a0norgate). When using vectors, the distinction between the two operator types becomes important. A bitwise operation between two N-bit vectors replicates the operation for each bit of the vector and produces a N-bit output, while a logical operation treats the entire vector as a boolean value (true = non-zero, false = zero) and produces a 1-bit output.</p> <p>Look at the simulation waveforms at how the bitwise-OR and logical-OR differ.</p> <p></p> Tip <p>Even though you cannot\u00a0<code>assign</code>\u00a0to a wire more than once, you can use a part select on the left-hand-side of an\u00a0<code>assign</code>. You don't need to assign to the entire vector all in one statement.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorgates/#official-solution","title":"Official Solution","text":"<pre><code>module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = a || b;\n\n    assign out_not[2:0] = ~a;   // Part-select on left side is o.\n    assign out_not[5:3] = ~b;   //Assigning to [5:3] does not conflict with [2:0]\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorgates/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = a||b;\n    assign out_not = {~b,~a};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorgates/#note","title":"Note","text":"<ul> <li> <p><code>|</code>\u662f\u6309\u4f4d\u6216\uff1a\u5c06 a \u7684\u6bcf\u4e2a\u4f4d\u4e0e b \u76f8\u540c\u7684\u4f4d\u8fdb\u884c\u76f8\u6216</p> </li> <li> <p><code>||</code>\u662f\u903b\u8f91\u6216\uff1aa \u6216\u4e0a b\uff0c\u5982\u679ca\u6216\u8005b\u6709\u4e00\u4e2a\u4e3a1\uff0ca||b\u7ed3\u679c\u4e3a1\uff0c\u8868\u793a\u771f\u3002</p> </li> <li> <p>\u8fd9\u9053\u9898\u7684<code>out_not</code>\u4e0d\u77e5\u9053<code>~a</code>\u3001<code>~b</code>\u62fc\u63a5\u7684\u5148\u540e\u987a\u5e8f\u3002</p> </li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorr/","title":"Vectorr","text":"<ul> <li>\u6765\u6e90\uff1aVectorr - HDLBits</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorr/#problem-statement","title":"Problem Statement","text":"<p>Given an 8-bit input vector [7:0], reverse its bit ordering.</p> Tip <p>assign out[7:0] = in[0:7];\u00a0does not work because Verilog does not allow vector bit ordering to be flipped. The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.</p>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorr/#official-solution","title":"Official Solution","text":"<pre><code>module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\n    /*\n    // I know you're dying to know how to use a loop to do this:\n\n    // Create a combinational always block. This creates combinational logic that computes the same result\n    // as sequential code. for-loops describe circuit *behaviour*, not *structure*, so they can only be used \n    // inside procedural blocks (e.g., always block).\n    // The circuit created (wires and gates) does NOT do any iteration: It only produces the same result\n    // AS IF the iteration occurred. In reality, a logic synthesizer will do the iteration at compile time to\n    // figure out what circuit to produce. (In contrast, a Verilog simulator will execute the loop sequentially\n    // during simulation.)\n    always @(*) begin   \n        for (int i=0; i&lt;8; i++) // int is a SystemVerilog type. Use integer for pure Verilog.\n            out[i] = in[8-i-1];\n    end\n\n\n    // It is also possible to do this with a generate-for loop. Generate loops look like procedural for loops,\n    // but are quite different in concept, and not easy to understand. Generate loops are used to make instantiations\n    // of \"things\" (Unlike procedural loops, it doesn't describe actions). These \"things\" are assign statements,\n    // module instantiations, net/variable declarations, and procedural blocks (things you can create when NOT inside \n    // a procedure). Generate loops (and genvars) are evaluated entirely at compile time. You can think of generate\n    // blocks as a form of preprocessing to generate more code, which is then run though the logic synthesizer.\n    // In the example below, the generate-for loop first creates 8 assign statements at compile time, which is then\n    // synthesized.\n    // Note that because of its intended usage (generating code at compile time), there are some restrictions\n    // on how you use them. Examples: 1. Quartus requires a generate-for loop to have a named begin-end block\n    // attached (in this example, named \"my_block_name\"). 2. Inside the loop body, genvars are read only.\n    generate\n        genvar i;\n        for (i=0; i&lt;8; i = i+1) begin: my_block_name\n            assign out[i] = in[8-i-1];\n        end\n    endgenerate\n    */\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorr/#my-solution","title":"My Solution","text":"<pre><code>module top_module( \n    input [7:0] in,\n    output [7:0] out\n);\n    assign {out[7],out[6],out[5],out[4],out[3],out[2],out[1],out[0]} = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};\n\nendmodule\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/FPGA/HDLBits%E7%BB%83%E4%B9%A0/VerilogLanguage/Vectors/Vectorr/#note","title":"Note","text":"<ul> <li> <p>\u770b\u6765\u7b54\u6848\uff0c\u53d1\u73b0\u6211\u7684\u4ee3\u7801\u6709\u70b9\u5197\u4f59\u3002</p> </li> <li> <p>\u5b98\u65b9\u4ee3\u7801\u7684\u6ce8\u91ca\u91cc\u9762\u63d0\u5230\u7528\u5faa\u73af\uff0c\u8fd9\u662f\u4e2a\u597d\u529e\u6cd5\u3002</p> </li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/Linux/%E9%80%80%E5%87%BAVim%E7%9A%84%E6%96%B9%E6%B3%95/","title":"\u9000\u51favim\u7684\u65b9\u6cd5","text":""},{"location":"%E5%AD%A6%E4%B9%A0/Linux/%E9%80%80%E5%87%BAVim%E7%9A%84%E6%96%B9%E6%B3%95/#vim","title":"\u9000\u51faVim\uff0c\u5982\u679c\u6709\u672a\u4fdd\u5b58\u7684\u66f4\u6539\uff0c\u5219\u4f1a\u5931\u8d25","text":"<pre><code>:q\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/Linux/%E9%80%80%E5%87%BAVim%E7%9A%84%E6%96%B9%E6%B3%95/#vim_1","title":"\u5f3a\u5236\u9000\u51faVim\uff0c\u4e0d\u4fdd\u5b58\u66f4\u6539","text":"<pre><code>:q!\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/Linux/%E9%80%80%E5%87%BAVim%E7%9A%84%E6%96%B9%E6%B3%95/#_1","title":"\u653e\u5f03\u6240\u6709\u4fee\u6539\uff0c\u4ece\u4e0a\u6b21\u4fdd\u5b58\u7684\u6587\u4ef6\u5f00\u59cb\u518d\u7f16\u8f91","text":"<pre><code>:e!\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/MarkDown/%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95/","title":"\u5f3a\u8c03\u8bed\u6cd5","text":"<ul> <li>\u53c2\u8003\uff1a\u5f3a\u8c03 | obsidian\u6587\u6863\u5496\u5561\u8c46\u7248</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/MarkDown/%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95/#_1","title":"\u4ee3\u7801","text":"<pre><code>*\u659c\u4f53* \n_\u659c\u4f53_    \n**\u7c97\u4f53**   \n__\u7c97\u4f53__\n`\u5185\u8054\u4ee3\u7801`  \n~~\u5220\u9664~~\n==\u9ad8\u4eae==\n</code></pre>"},{"location":"%E5%AD%A6%E4%B9%A0/MarkDown/%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95/#_2","title":"\u6548\u679c","text":"<p>\u659c\u4f53 </p> <p>\u659c\u4f53 </p> <p>\u7c97\u4f53 </p> <p>\u7c97\u4f53</p> <p><code>\u5185\u8054\u4ee3\u7801</code> </p> <p>~~\u5220\u9664~~</p> <p>==\u9ad8\u4eae==</p>"},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","title":"MkDocs\u5b89\u88c5\u6559\u7a0b","text":"","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#mkdocs","title":"\u5b89\u88c5 MkDocs","text":"<ul> <li> <p>\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u8fdb\u884c\u5b89\u88c5MkDocs <pre><code>pip install mkdocs\n</code></pre></p> </li> <li> <p>\u5b89\u88c5<code>material</code>\u4e3b\u9898 <pre><code>pip install mkdocs-material\n</code></pre></p> </li> <li> <p>\u5b89\u88c5\u5b8c\u6210\u540e\u9a8c\u8bc1\u662f\u5426\u5b89\u88c5\u6210\u529f <pre><code>mkdocs --version\n</code></pre></p> </li> </ul>","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#mkdocs_1","title":"\u521b\u5efa MkDocs \u9879\u76ee","text":"<pre><code>mkdocs new &lt;\u9879\u76ee\u540d\u79f0&gt;\n</code></pre>","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#_1","title":"\u542f\u52a8\u672c\u5730\u670d\u52a1\u5668","text":"<p><pre><code>mkdocs serve\n</code></pre> - \u5728\u6d4f\u89c8\u5668\u6253\u5f00\u00a0<code>http://127.0.0.1:8000</code>\u8fdb\u884c\u9884\u89c8\u3002</p>","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#_2","title":"\u751f\u6210\u9759\u6001\u6587\u4ef6","text":"<pre><code>mkdocs build\n</code></pre>","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#github","title":"\u90e8\u7f72\u5230Github","text":"<pre><code>mkdocs gh-deploy\n</code></pre>","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/MkDocs/MkDocs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#_3","title":"\u53c2\u8003\u6587\u6863","text":"<ul> <li>Material for MkDocs - Material for MkDocs \u4e2d\u6587\u6587\u6863</li> <li>\u6700\u725b\u903c\u7684Python\u6587\u6863\u751f\u6210\u5de5\u5177\u2014\u2014MkDocs\uff0c\u624b\u628a\u624b\u6559\u4f60\u642d\u5efa\u6587\u6863\u7f51\u7ad9 | \u6781\u5ba2\u4e4b\u97f3</li> <li>Material for MkDocs</li> </ul>","tags":["\u6559\u7a0b"]},{"location":"%E5%AD%A6%E4%B9%A0/Rust/Burn%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/","title":"Burn\u5bfc\u5165\u95ee\u9898","text":"<ul> <li>\u65e5\u671f\uff1a2025\u5e747\u67081\u65e5</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/Rust/Burn%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/#_1","title":"\u53d1\u751f\u65f6\u673a","text":"<p>\u5728cargo.toml\u6587\u4ef6\u4e2d\u6dfb\u52a0\u4f9d\u8d56\uff1a <pre><code>burn = { version = \"0.17.1\", features = [\"wgpu\"] }\nspider = \"2.37.126\"\n</code></pre></p>"},{"location":"%E5%AD%A6%E4%B9%A0/Rust/Burn%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/#_2","title":"\u62a5\u9519","text":"<p>\u51fa\u73b0\u62a5\u9519\uff1a <pre><code>error: failed to select a version for `libsqlite3-sys`.\n    ... required by package `sqlx-sqlite v0.8.0`\n    ... which satisfies dependency `sqlx-sqlite = \"=0.8.0\"` of package `sqlx v0.8.0`\n    ... which satisfies dependency `sqlx = \"^0.8\"` of package `spider v2.37.126`\n    ... which satisfies dependency `spider = \"^2.37.126\"` of package `rust_test v0.1.0 (C:\\Users\\TFC\\Documents\\MyProjects\\rust_test)`\nversions that meet the requirements `^0.28.0` are: 0.28.0\n\npackage `libsqlite3-sys` links to the native library `sqlite3`, but it conflicts with a previous package which links to `sqlite3` as well:\npackage `libsqlite3-sys v0.32.0`\n    ... which satisfies dependency `libsqlite3-sys = \"^0.32.0\"` of package `rusqlite v0.34.0`\n    ... which satisfies dependency `rusqlite = \"^0.34.0\"` of package `burn-dataset v0.17.1`\n    ... which satisfies dependency `burn-dataset = \"^0.17.1\"` of package `burn-core v0.17.1`\n    ... which satisfies dependency `burn-core = \"^0.17.1\"` of package `burn v0.17.1`\n    ... which satisfies dependency `burn = \"^0.17.1\"` of package `rust_test v0.1.0 (C:\\Users\\TFC\\Documents\\MyProjects\\rust_test)`\nOnly one package in the dependency graph may specify the same links value. This helps ensure that only one copy of a native library is linked in the final binary. Try to adjust your dependencies so that only one package uses the `links = \"sqlite3\"` value. For more information, see https://doc.rust-lang.org/cargo/reference/resolver.html#links.\n\nfailed to select a version for `libsqlite3-sys` which could resolve this conflict\n</code></pre></p>"},{"location":"%E5%AD%A6%E4%B9%A0/Rust/Burn%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/#_3","title":"\u5206\u6790","text":"<p>\u51b2\u7a81\u53d1\u751f\u5728<code>libsqlite3-sys v0.32.0</code>\u8fd9\u4e2a\u5305\u3002</p>"},{"location":"%E5%AD%A6%E4%B9%A0/Rust/Burn%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/#_4","title":"\u89e3\u51b3","text":"<p>\u4e0d\u8981\u540c\u65f6\u4f7f\u7528\u8fd9\u4e24\u4e2a\u4f9d\u8d56\u3002</p> <p>\u57282025\u5e747\u67081\u65e5\u4e24\u4e2a\u5305\u5747\u4f7f\u7528\u6700\u65b0\u7248\u672c\uff0c\u4f1a\u53d1\u751f\u4f9d\u8d56\u51b2\u7a81\uff0c\u4e0d\u77e5\u9053\u4ee5\u540e\u8fd9\u4e24\u4e2a\u5305\u5347\u7ea7\u4e86\u4f1a\u4e0d\u4f1a\u5c31\u4e0d\u4f1a\u51b2\u7a81\u4e86\u3002</p>"},{"location":"%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"\u77e5\u7f51\u7814\u5b66\u767b\u5f55\u5931\u8d25\u89e3\u51b3\u529e\u6cd5","text":"<ul> <li>\u53c2\u8003\uff1a\u77e5\u7f51\u7814\u5b66\u767b\u5f55\u5931\u8d25\u600e\u4e48\u56de\u4e8b\uff1f - \u77e5\u4e4e</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/#_1","title":"\u95ee\u9898","text":"<ul> <li>\u65e0\u6cd5\u767b\u5f55\uff0c\u51fa\u73b0\uff1a\u767b\u5f55\u5931\u8d25,\u670d\u52a1\u5668\u6216\u7f51\u7edc\u5f02\u5e38,\u8bf7\u7a0d\u540e\u5c1d\u8bd5\u3002\u83b7\u53d6\u670d\u52a1\u5668\u8ba4\u8bc1\u5931\u8d25\u3002\u7f51\u7edc\u8fde\u63a5\u5931\u8d25,\u9519\u8bef\u7801:28(28)</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/#_2","title":"\u5206\u6790","text":"<ul> <li>\u56e0\u4e3a\u4f7f\u7528\u8fc7Watt Toolkit\uff0cDNS\u88ab\u4fee\u6539\uff0c\u4fee\u6539DNS\u4e3a\u81ea\u52a8\u5206\u914d\u5373\u53ef</li> </ul>"},{"location":"%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6/%E7%9F%A5%E7%BD%91%E7%A0%94%E5%AD%A6%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/#_3","title":"\u89e3\u51b3","text":"<ul> <li>\u5728\u7f51\u7edc\u5c5e\u6027\u4e2d\u8bbe\u7f6eDNS\u4e3a\u81ea\u52a8(DHCP)</li> <li>\u8bbe\u7f6e\u597d\u4e4b\u540e\u91cd\u542f\u7535\u8111</li> </ul>"}]}